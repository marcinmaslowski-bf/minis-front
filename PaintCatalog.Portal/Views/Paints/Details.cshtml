@using System.Collections.Generic
@using System.Linq
@using System.Text.Json
@using System.Text.Encodings.Web
@using PaintCatalog.Portal.Helpers
@model PaintCatalog.Portal.Models.PaintDetailsViewModel
@inject Microsoft.AspNetCore.Mvc.Localization.IViewLocalizer Localizer
@inject Microsoft.AspNetCore.Mvc.Localization.IHtmlLocalizerFactory LocalizerFactory

@{
    ViewData["Title"] = Localizer["Page_Title"].Value;
    ViewData["MetaDescription"] = Localizer["Page_Description"].Value;

    var detailsJson = string.IsNullOrWhiteSpace(Model.PaintJson) ? "null" : Model.PaintJson;
    var searchLocalizer = LocalizerFactory.Create("Views.Paints.Index", typeof(Program).Assembly.GetName().Name);
    var enumLabels = EnumLabelHelper.CreatePaintEnumLabels(searchLocalizer);
    var jsonOptions = new JsonSerializerOptions
    {
        Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping
    };

    var bootstrap = new
    {
        paint = Model.PaintJson,
        brandSlug = Model.BrandSlug,
        seriesSlug = Model.SeriesSlug,
        paintSlug = Model.PaintSlug,
        commentEndpoints = new
        {
            thread = Url.Action("Thread", "Comments", new { threadId = "__thread__" }) ?? "/comments/__thread__",
            count = Url.Action("Count", "Comments", new { threadId = "__thread__" }) ?? "/comments/__thread__/count",
            create = Url.Action("Create", "Comments", new { threadId = "__thread__" }) ?? "/comments/__thread__",
            update = Url.Action("Update", "Comments", new { threadId = "__thread__", commentId = "__comment__" }) ?? "/comments/__thread__/__comment__"
        },
        voteEndpoints = new
        {
            summary = Url.Action("SummaryById", "Votes", new { threadId = "__thread__" }) ?? "/votes/__thread__/summary",
            set = Url.Action("Set", "Votes", new { threadId = "__thread__" }) ?? "/votes/__thread__"
        },
        bookmarkEndpoints = new
        {
            categories = Url.Action("Categories", "Bookmarks") ?? "/bookmarks/categories",
            createCategory = Url.Action("CreateCategory", "Bookmarks") ?? "/bookmarks/categories",
            upsert = Url.Action("Upsert", "Bookmarks") ?? "/bookmarks",
            get = Url.Action("Get", "Bookmarks", new { itemType = "__type__", itemId = "__id__" }) ?? "/bookmarks/__type__/__id__",
            delete = Url.Action("Delete", "Bookmarks", new { itemType = "__type__", itemId = "__id__" }) ?? "/bookmarks/__type__/__id__"
        },
        auth = new
        {
            isAuthenticated = User?.Identity?.IsAuthenticated ?? false,
            userId = User?.FindFirst("sub")?.Value ?? User?.FindFirst("preferred_username")?.Value ?? User?.Identity?.Name ?? string.Empty,
            userName = User?.FindFirst("name")?.Value ?? User?.Identity?.Name ?? string.Empty,
            loginUrl = Url.Action("Login", "Account", new { returnUrl = Context.Request.Path + Context.Request.QueryString }) ?? "/login"
        },
        enumLabels = new
        {
            type = enumLabels.Types,
            sheen = enumLabels.Sheens,
            medium = enumLabels.Mediums
        }
    };

    var bootstrapJson = JsonSerializer.Serialize(bootstrap, jsonOptions);
    var backToSearchUrl = Url.LocalizedAction("Index", "Paints");

    var errorMessage = Model.ErrorMessage;
    if (string.IsNullOrWhiteSpace(errorMessage))
    {
        errorMessage = Model.ErrorCode switch
        {
            "unauthorized" => Localizer["Details_Error_Unauthorized"].Value,
            "api_unavailable" => Localizer["Details_Error_ApiUnavailable"].Value,
            "unexpected" => Localizer["Details_Error_Unexpected"].Value,
            _ => Localizer["Details_Error_Description"].Value
        };
    }
}

<section class="space-y-8">
    <div class="flex items-center justify-between gap-4">
        <div>
            <h1 class="text-3xl font-extrabold text-slate-900 dark:text-white" id="paint-name"></h1>
            <p class="mt-1 text-sm text-slate-500 dark:text-slate-300"><span id="paint-brand"></span>: <span id="paint-series"></span></p>
        </div>
        <div class="flex items-center gap-2">
            <button id="bookmark-trigger" type="button" class="inline-flex items-center gap-2 rounded-full border border-slate-200 px-3 py-1 text-xs font-semibold uppercase tracking-wide text-slate-700 transition hover:border-emerald-400 hover:text-emerald-600 focus:outline-none focus:ring-2 focus:ring-emerald-400 dark:border-slate-700 dark:text-slate-200 dark:hover:border-emerald-500 dark:hover:text-emerald-300">
                <span aria-hidden="true">★</span>
                <span>@Localizer["Bookmark_Button_Save"]</span>
            </button>
            <a href="@backToSearchUrl" class="inline-flex items-center gap-2 rounded-full border border-slate-200 px-3 py-1 text-xs font-semibold uppercase tracking-wide text-slate-600 transition hover:border-emerald-400 hover:text-emerald-600 focus:outline-none focus:ring-2 focus:ring-emerald-400 dark:border-slate-700 dark:text-slate-200 dark:hover:border-emerald-500 dark:hover:text-emerald-300">
                <span aria-hidden="true">←</span>
                <span>@Localizer["Details_Back"]</span>
            </a>
        </div>
    </div>

    <div id="paint-details" class="rounded-2xl border border-slate-200 bg-white/90 p-6 shadow-sm dark:border-slate-800 dark:bg-slate-900/80">
        <div class="flex flex-col gap-6 lg:grid lg:grid-cols-3 lg:items-start lg:gap-8">
            <div class="lg:order-2 space-y-2 lg:col-span-1 lg:justify-self-end lg:w-full">
                <div class="h-28 w-full rounded-2xl border border-2 border-slate-200 shadow-inner dark:border-slate-800 sm:h-32 sm:w-full lg:h-36 lg:w-full" id="paint-swatch"></div>
                <div id="vote-controls" class="flex flex-wrap items-center justify-end gap-2 text-sm text-slate-600 dark:text-slate-200" hidden>
                    <button id="vote-up" type="button" class="grid h-9 w-9 place-items-center rounded-full border border-slate-200 text-slate-500 transition hover:border-emerald-500 hover:text-emerald-600 disabled:opacity-60 dark:border-slate-700 dark:text-slate-300 dark:hover:border-emerald-500" aria-label="@Localizer["Card_Label_Vote_Up", "Upvote"]">▲</button>
                    <span id="vote-score" class="min-w-[2.5rem] rounded-full border border-slate-200 px-3 py-1 text-center font-semibold dark:border-slate-700">—</span>
                    <button id="vote-down" type="button" class="grid h-9 w-9 place-items-center rounded-full border border-slate-200 text-slate-500 transition hover:border-red-500 hover:text-red-600 disabled:opacity-60 dark:border-slate-700 dark:text-slate-300 dark:hover:border-red-400" aria-label="@Localizer["Card_Label_Vote_Down", "Downvote"]">▼</button>
                </div>
            </div>
            <div class="lg:order-1 space-y-3 lg:col-span-2">
                <h2 class="text-2xl font-bold text-slate-900 dark:text-white"></h2>                
                <p class="text-sm text-slate-500 dark:text-slate-300" id="paint-description"></p>
                <dl class="grid grid-cols-2 gap-4 text-sm text-slate-600 dark:text-slate-200">
                    <div>
                        <dt class="font-semibold text-slate-400">@Localizer["Card_Label_Type"]</dt>
                        <dd class="mt-1 text-slate-900 dark:text-slate-100" id="paint-type">—</dd>
                    </div>
                    <div>
                        <dt class="font-semibold text-slate-400">@Localizer["Card_Label_Finish"]</dt>
                        <dd class="mt-1 text-slate-900 dark:text-slate-100" id="paint-sheen">—</dd>
                    </div>
                    <div>
                        <dt class="font-semibold text-slate-400">@Localizer["Card_Label_Medium"]</dt>
                        <dd class="mt-1 text-slate-900 dark:text-slate-100" id="paint-medium">—</dd>
                    </div>
                    <div>
                        <dt class="font-semibold text-slate-400">@Localizer["Card_Label_Sku"]</dt>
                        <dd class="mt-1 text-slate-900 dark:text-slate-100" id="paint-sku">—</dd>
                    </div>
                </dl>
                <dl class="grid grid-cols-1 gap-4 text-sm text-slate-600 dark:text-slate-200">
                    <div>
                        <dt class="font-semibold text-slate-400">@Localizer["Card_Label_Discontinued"]</dt>
                        <dd class="mt-1 text-slate-900 dark:text-slate-100" id="paint-discontinued">—</dd>
                    </div>
                    <div>
                        <dt class="font-semibold text-slate-400">@Localizer["Card_Label_BrandWebsite"]</dt>
                        <dd class="mt-1 text-slate-900 dark:text-slate-100" id="paint-brand-website">—</dd>
                    </div>
                    <div>
                        <dt class="font-semibold text-slate-400">@Localizer["Card_Label_Identifiers"]</dt>
                        <dd class="mt-1 space-y-1 text-slate-900 dark:text-slate-100" id="paint-identifiers">—</dd>
                    </div>
                </dl>
                <div class="flex flex-wrap gap-2" id="paint-tags"></div>
            </div>
            
        </div>
    </div>

    <div id="paint-error" class="hidden rounded-xl border border-red-200 bg-red-50 p-4 text-red-800 dark:border-red-900 dark:bg-red-950 dark:text-red-200">
        <p class="font-semibold">@Localizer["Details_Error_Title"]</p>
        <p class="text-sm">@errorMessage</p>
    </div>

    <div id="bookmark-modal" class="fixed inset-0 z-50 hidden items-center justify-center bg-slate-900/40 p-4">
        <div class="w-full max-w-lg rounded-2xl bg-white p-6 shadow-xl dark:bg-slate-900">
            <div class="space-y-1">
                <p class="text-lg font-semibold text-slate-900 dark:text-white">@Localizer["Bookmark_Title"]</p>
                <p class="text-sm text-slate-500 dark:text-slate-300">@Localizer["Bookmark_Subtitle"]</p>
            </div>

            <div class="mt-5 space-y-4">
                <div class="space-y-1">
                    <label for="bookmark-category" class="text-sm font-semibold text-slate-700 dark:text-slate-200">@Localizer["Bookmark_Category_Label"]</label>
                    <select id="bookmark-category" class="w-full rounded-xl border border-slate-300 bg-white/90 p-3 text-sm text-slate-900 focus:border-emerald-500 focus:outline-none focus:ring-2 focus:ring-emerald-500/40 dark:border-slate-700 dark:bg-slate-950/50 dark:text-slate-100"></select>
                </div>

                <div class="space-y-2">
                    <label for="bookmark-new-category" class="text-sm font-semibold text-slate-700 dark:text-slate-200">@Localizer["Bookmark_NewCategory_Label"]</label>
                    <div class="flex flex-col gap-2 sm:flex-row">
                        <input id="bookmark-new-category" type="text" maxlength="80" placeholder="@Localizer["Bookmark_NewCategory_Placeholder"]" class="w-full rounded-xl border border-slate-300 bg-white/90 p-3 text-sm text-slate-900 focus:border-emerald-500 focus:outline-none focus:ring-2 focus:ring-emerald-500/40 dark:border-slate-700 dark:bg-slate-950/50 dark:text-slate-100" />
                        <button id="bookmark-add-category" type="button" class="inline-flex items-center justify-center rounded-xl border border-slate-300 px-4 py-2 text-sm font-semibold text-slate-700 transition hover:border-emerald-500 hover:text-emerald-600 focus:outline-none focus:ring-2 focus:ring-emerald-400 dark:border-slate-700 dark:text-slate-200 dark:hover:border-emerald-500 dark:hover:text-emerald-300">@Localizer["Bookmark_AddCategory_Button"]</button>
                    </div>
                </div>

                <div class="space-y-1">
                    <label for="bookmark-note" class="text-sm font-semibold text-slate-700 dark:text-slate-200">@Localizer["Bookmark_Note_Label"]</label>
                    <textarea id="bookmark-note" rows="3" placeholder="@Localizer["Bookmark_Note_Placeholder"]" class="w-full rounded-xl border border-slate-300 bg-white/80 p-3 text-sm text-slate-900 placeholder:text-slate-400 focus:border-emerald-500 focus:outline-none focus:ring-2 focus:ring-emerald-500/40 dark:border-slate-700 dark:bg-slate-950/40 dark:text-slate-100"></textarea>
                </div>

                <div id="bookmark-status" class="hidden text-sm font-semibold text-emerald-600 dark:text-emerald-300"></div>
                <div id="bookmark-error" class="hidden text-sm font-semibold text-rose-600 dark:text-rose-300"></div>

                <div class="flex flex-wrap justify-end gap-2">
                    <button id="bookmark-remove" type="button" class="rounded-xl border border-slate-300 px-4 py-2 text-sm font-semibold text-slate-700 transition hover:border-rose-400 hover:text-rose-600 focus:outline-none focus:ring-2 focus:ring-rose-300 dark:border-slate-700 dark:text-slate-200 dark:hover:border-rose-400 dark:hover:text-rose-300">@Localizer["Bookmark_Remove"]</button>
                    <button id="bookmark-cancel" type="button" class="rounded-xl border border-slate-300 px-4 py-2 text-sm font-semibold text-slate-700 transition hover:border-slate-400 focus:outline-none focus:ring-2 focus:ring-slate-300 dark:border-slate-700 dark:text-slate-200 dark:hover:border-slate-500">@Localizer["Bookmark_Cancel"]</button>
                    <button id="bookmark-save" type="button" class="rounded-xl bg-emerald-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-emerald-700 focus:outline-none focus:ring-2 focus:ring-emerald-400">@Localizer["Bookmark_Save"]</button>
                </div>
            </div>
        </div>
    </div>

    <section id="comments-section" class="hidden rounded-2xl border border-slate-200 bg-white/90 p-6 shadow-sm dark:border-slate-800 dark:bg-slate-900/80">
        <div class="flex flex-wrap items-center justify-between gap-4">
            <div class="flex items-center gap-3">
                <span class="grid h-12 w-12 place-items-center rounded-xl bg-emerald-500/10 text-emerald-600 dark:text-emerald-300" data-icon="comment"></span>
                <div>
                    <p class="text-lg font-semibold text-slate-900 dark:text-white">@Localizer["Comments_Title"]</p>
                    <p class="text-sm text-slate-500 dark:text-slate-300">@Localizer["Comments_Subtitle"]</p>
                </div>
            </div>
            <span class="inline-flex items-center gap-2 rounded-full border border-slate-200 px-3 py-1 text-sm font-semibold text-slate-700 dark:border-slate-700 dark:text-slate-100">
                <span data-icon="comment"></span>
                <span id="comments-count">0</span>
            </span>
        </div>

        <div class="mt-4 grid gap-6 lg:grid-cols-[1.7fr_minmax(260px,0.9fr)]">
            <div class="space-y-4">
                <div id="comments-error" class="hidden rounded-lg border border-red-200 bg-red-50 p-3 text-sm text-red-800 dark:border-red-900 dark:bg-red-950/60 dark:text-red-100"></div>
                <div id="comments-loading" class="hidden rounded-lg border border-slate-200 bg-white/70 p-3 text-sm text-slate-600 dark:border-slate-700 dark:bg-slate-900/60 dark:text-slate-200">@Localizer["Comments_Loading"]</div>
                <div id="comments-empty" class="hidden rounded-lg border border-slate-200 bg-white/70 p-3 text-sm text-slate-600 dark:border-slate-700 dark:bg-slate-900/60 dark:text-slate-200">@Localizer["Comments_Empty"]</div>
                <div id="comment-list" class="space-y-3"></div>

                <div class="border-t border-slate-200 pt-4 dark:border-slate-700">
                    <div id="comments-login-notice" class="mb-3 hidden rounded-lg border border-amber-200 bg-amber-50 p-3 text-sm text-amber-800 dark:border-amber-800 dark:bg-amber-950/60 dark:text-amber-100">
                        @Localizer["Comments_Login_Prompt"] <a href="@(Url.Action("Login", "Account", new { returnUrl = Context.Request.Path + Context.Request.QueryString }) ?? "/login")" class="font-semibold text-emerald-600 underline dark:text-emerald-400">@Localizer["Comments_Login_Link"]</a>.
                    </div>
                    <form id="comment-form" class="space-y-3">
                        <div class="space-y-1">
                            <label for="comment-input" class="text-sm font-semibold text-slate-700 dark:text-slate-200">@Localizer["Comments_Form_Label"]</label>
                            <textarea id="comment-input" rows="3" placeholder="@Localizer["Comments_Form_Placeholder"]" class="w-full rounded-xl border border-slate-300 bg-white/80 p-3 text-sm text-slate-900 placeholder:text-slate-400 focus:border-emerald-500 focus:outline-none focus:ring-2 focus:ring-emerald-500/40 dark:border-slate-700 dark:bg-slate-950/40 dark:text-slate-100"></textarea>
                        </div>
                        <div class="space-y-2">
                            <div class="flex items-center gap-2">
                                <label for="comment-attachment-input" class="text-sm font-semibold text-slate-700 dark:text-slate-200">@Localizer["Comments_Attachments_Label"]</label>
                                <span class="text-xs text-slate-500 dark:text-slate-400">@Localizer["Comments_Attachments_Help"]</span>
                            </div>
                            <input id="comment-attachment-input" type="file" class="hidden" multiple />
                            <div class="flex flex-wrap items-center gap-2">
                                <button id="comment-attachment-button" type="button" class="flex items-center gap-2 rounded-xl border border-slate-300 px-3 py-2 text-xs font-semibold text-slate-700 transition hover:border-emerald-500 hover:text-emerald-600 focus:outline-none focus:ring-2 focus:ring-emerald-400 dark:border-slate-700 dark:text-slate-200 dark:hover:border-emerald-500 dark:hover:text-emerald-300">
                                    <span class="rounded-lg bg-emerald-500/10 p-1 text-emerald-600 dark:text-emerald-300" data-icon="attachment"></span>
                                    <span>@Localizer["Comments_Attachments_Add"]</span>
                                </button>
                                <div id="comment-attachments" class="flex flex-wrap items-center gap-2"></div>
                            </div>
                        </div>
                        <div class="flex flex-wrap items-center gap-3">
                            <button id="comment-submit" type="submit" class="rounded-xl bg-emerald-600 px-4 py-2 text-sm font-semibold text-white transition hover:bg-emerald-700 disabled:opacity-50 disabled:hover:bg-emerald-600">@Localizer["Comments_Submit"]</button>
                            <button id="comment-cancel-edit" type="button" class="hidden rounded-xl border border-slate-300 px-3 py-2 text-sm font-semibold text-slate-700 transition hover:border-emerald-500 hover:text-emerald-600 focus:outline-none focus:ring-2 focus:ring-emerald-400 dark:border-slate-700 dark:text-slate-200 dark:hover:border-emerald-500 dark:hover:text-emerald-300">@Localizer["Comments_CancelEdit"]</button>
                            <span id="comment-status" class="hidden text-xs text-slate-500 dark:text-slate-400"></span>
                        </div>
                    </form>
                </div>
            </div>

            <aside id="comment-gallery" class="hidden space-y-2 rounded-xl border border-slate-200 bg-slate-50 p-4 text-sm text-slate-700 shadow-sm dark:border-slate-800 dark:bg-slate-900/60 dark:text-slate-200">
                <div class="flex items-start justify-between gap-3">
                    <div>
                        <p class="text-sm font-semibold text-slate-900 dark:text-white">@Localizer["Comments_Gallery_Title"]</p>
                        <p class="text-xs text-slate-500 dark:text-slate-400">@Localizer["Comments_Gallery_Subtitle"]</p>
                    </div>
                    <span class="rounded-full bg-emerald-500/10 px-2 py-1 text-[11px] font-semibold text-emerald-600 dark:bg-emerald-500/20 dark:text-emerald-300" id="comment-gallery-count">0</span>
                </div>
                <div id="comment-gallery-grid" class="grid grid-cols-2 content-start gap-3 sm:grid-cols-3"></div>
            </aside>
        </div>
    </section>
</section>

@section Scripts {
    <script src="~/js/bookmarks.js"></script>
    <script src="~/js/paint-swatch.js"></script>
    <script>
        (function() {
            const bootstrap = @Html.Raw(bootstrapJson);
            const rawJson = @Html.Raw(detailsJson);
            const enumLabels = bootstrap.enumLabels || {};
            const localized = {
                discontinuedYes: @Html.Raw(JsonSerializer.Serialize(Localizer["Card_Value_Discontinued_Yes"].Value, jsonOptions)),
                discontinuedNo: @Html.Raw(JsonSerializer.Serialize(Localizer["Card_Value_Discontinued_No"].Value, jsonOptions)),
                discontinuedUnknown: @Html.Raw(JsonSerializer.Serialize(Localizer["Card_Value_Discontinued_Unknown"].Value, jsonOptions)),
                brandWebsiteUnavailable: @Html.Raw(JsonSerializer.Serialize(Localizer["Card_Value_BrandWebsite_Unavailable"].Value, jsonOptions)),
                identifiersNone: @Html.Raw(JsonSerializer.Serialize(Localizer["Card_Value_Identifiers_None"].Value, jsonOptions)),
                comments: {
                    error: @Html.Raw(JsonSerializer.Serialize(Localizer["Comments_Error_Generic"].Value, jsonOptions)),
                    unavailable: @Html.Raw(JsonSerializer.Serialize(Localizer["Comments_Error_Unavailable"].Value, jsonOptions)),
                    saved: @Html.Raw(JsonSerializer.Serialize(Localizer["Comments_Status_Saved"].Value, jsonOptions)),
                    updated: @Html.Raw(JsonSerializer.Serialize(Localizer["Comments_Status_Updated"].Value, jsonOptions)),
                    loginCta: @Html.Raw(JsonSerializer.Serialize(Localizer["Comments_Login_Cta"].Value, jsonOptions)),
                    edit: @Html.Raw(JsonSerializer.Serialize(Localizer["Comments_Edit"].Value, jsonOptions)),
                    editedLabel: @Html.Raw(JsonSerializer.Serialize(Localizer["Comments_Edited_Label"].Value, jsonOptions)),
                    attachmentsEmpty: @Html.Raw(JsonSerializer.Serialize(Localizer["Comments_Attachments_Empty"].Value, jsonOptions)),
                    attachmentsRemove: @Html.Raw(JsonSerializer.Serialize(Localizer["Comments_Attachments_Remove"].Value, jsonOptions)),
                attachmentsTooLarge: @Html.Raw(JsonSerializer.Serialize(Localizer["Comments_Attachments_TooLarge"].Value, jsonOptions)),
                attachmentsLimit: @Html.Raw(JsonSerializer.Serialize(Localizer["Comments_Attachments_Limit"].Value, jsonOptions)),
                attachmentsReadError: @Html.Raw(JsonSerializer.Serialize(Localizer["Comments_Attachments_ReadError"].Value, jsonOptions))
                },
                bookmarks: {
                    buttonSave: @Html.Raw(JsonSerializer.Serialize(Localizer["Bookmark_Button_Save"].Value, jsonOptions)),
                    buttonSaved: @Html.Raw(JsonSerializer.Serialize(Localizer["Bookmark_Button_Saved"].Value, jsonOptions)),
                    statusSaved: @Html.Raw(JsonSerializer.Serialize(Localizer["Bookmark_Status_Saved"].Value, jsonOptions)),
                    statusRemoved: @Html.Raw(JsonSerializer.Serialize(Localizer["Bookmark_Status_Removed"].Value, jsonOptions)),
                    errorLoad: @Html.Raw(JsonSerializer.Serialize(Localizer["Bookmark_Error_Load"].Value, jsonOptions)),
                    errorSave: @Html.Raw(JsonSerializer.Serialize(Localizer["Bookmark_Error_Save"].Value, jsonOptions)),
                    errorDelete: @Html.Raw(JsonSerializer.Serialize(Localizer["Bookmark_Error_Delete"].Value, jsonOptions)),
                    login: @Html.Raw(JsonSerializer.Serialize(Localizer["Bookmark_Login"].Value, jsonOptions))
                }
            };

            const commentEndpoints = bootstrap.commentEndpoints || {};
            const voteEndpoints = bootstrap.voteEndpoints || {};
            const bookmarkEndpoints = bootstrap.bookmarkEndpoints || {};
            const auth = bootstrap.auth || {};

            const getIconMarkup = (id, fallback = '') => {
                try {
                    const markup = window.appIcons?.get?.(id);
                    return markup || fallback;
                } catch (_) {
                    return fallback;
                }
            };

            const icons = {
                comment: getIconMarkup('icon-comment', '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M20.25 13.5c0 1.682-.5 3.256-1.368 4.59-.316.5-.102 1.159.383 1.488.554.374.845 1 .699 1.641a1.678 1.678 0 0 1-1.148 1.215c-1.046.323-2.226-.057-2.968-.92a8.73 8.73 0 0 1-1.182-1.868c-.396-.8-1.289-1.246-2.175-1.014a8.42 8.42 0 0 1-2.665.259c-3.958-.343-7.151-3.54-7.49-7.501C1.91 6.22 6.16 2.25 11.22 2.25c5.059 0 9.03 4.162 9.03 9.3Z" /><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 10.125h.007m3.743 0H12m3.743 0h.007" /></svg>'),
                attachment: getIconMarkup('icon-attachment', '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 6.75 8.982 13.5a2.25 2.25 0 1 0 3.182 3.183l5.143-5.144a3.75 3.75 0 0 0-5.304-5.304L6.86 10.125" /></svg>')
            };

            const state = {
                paint: null,
                brandSlug: bootstrap.brandSlug,
                seriesSlug: bootstrap.seriesSlug,
                paintSlug: bootstrap.paintSlug,
                commentThreadId: null,
                voteThreadId: null,
                voteSummary: null,
                voteLoading: false,
                comments: [],
                commentCount: null,
                commentsLoading: false,
                attachments: [],
                commentError: '',
                isSubmittingComment: false,
                editingCommentId: null,
                auth: {
                    isAuthenticated: !!auth.isAuthenticated,
                    userId: auth.userId || '',
                    userName: auth.userName || '',
                    loginUrl: auth.loginUrl || '/login'
                }
            };

            const commentElements = {
                section: document.getElementById('comments-section'),
                count: document.getElementById('comments-count'),
                list: document.getElementById('comment-list'),
                empty: document.getElementById('comments-empty'),
                error: document.getElementById('comments-error'),
                loading: document.getElementById('comments-loading'),
                loginNotice: document.getElementById('comments-login-notice'),
                form: document.getElementById('comment-form'),
                input: document.getElementById('comment-input'),
                attachmentInput: document.getElementById('comment-attachment-input'),
                attachmentButton: document.getElementById('comment-attachment-button'),
                attachments: document.getElementById('comment-attachments'),
                submit: document.getElementById('comment-submit'),
                cancelEdit: document.getElementById('comment-cancel-edit'),
                status: document.getElementById('comment-status'),
                gallery: document.getElementById('comment-gallery'),
                galleryGrid: document.getElementById('comment-gallery-grid'),
                galleryCount: document.getElementById('comment-gallery-count')
            };

            const voteElements = {
                container: document.getElementById('vote-controls'),
                up: document.getElementById('vote-up'),
                down: document.getElementById('vote-down'),
                score: document.getElementById('vote-score')
            };

            const bookmarkSelectors = {
                triggerSelector: '#bookmark-trigger',
                modalSelector: '#bookmark-modal',
                categorySelector: '#bookmark-category',
                newCategorySelector: '#bookmark-new-category',
                addCategorySelector: '#bookmark-add-category',
                noteSelector: '#bookmark-note',
                saveSelector: '#bookmark-save',
                removeSelector: '#bookmark-remove',
                cancelSelector: '#bookmark-cancel',
                statusSelector: '#bookmark-status',
                errorSelector: '#bookmark-error'
            };

            function injectIcons() {
                document.querySelectorAll('[data-icon="comment"]').forEach(el => {
                    if (icons.comment) {
                        el.innerHTML = icons.comment;
                    }
                });

                document.querySelectorAll('[data-icon="attachment"]').forEach(el => {
                    if (icons.attachment) {
                        el.innerHTML = icons.attachment;
                    }
                });
            }

            injectIcons();

            if (voteElements.up) {
                voteElements.up.addEventListener('click', () => handleVote(1));
            }

            if (voteElements.down) {
                voteElements.down.addEventListener('click', () => handleVote(-1));
            }

            const swatchUtils = window.paintSwatchUtils || {};
            const normalizeHex = swatchUtils.normalizeHex || (value => {
                if (!value) return null;
                const hex = String(value).trim();
                if (!hex) return null;
                return hex.startsWith('#') ? hex : `#${hex}`;
            });
            const buildPaintSwatch = swatchUtils.buildPaintSwatch || ((paint, fallbackHex, options = {}) => {
                const hex = normalizeHex(options.defaultHex) || normalizeHex(fallbackHex) || '#0f172a';
                return { background: hex, label: hex };
            });
            const resolveEnumLabel = (dictionary, rawValue, fallback) => {
                if (!dictionary) return fallback;

                let value = rawValue;
                if (value && typeof value === 'object') {
                    value = value.id ?? value.value ?? value.type ?? value.sheen ?? value.medium;
                }

                if (value === null || value === undefined) return fallback;

                const key = String(value);
                const direct = dictionary[key];
                if (direct) return direct;

                const numeric = parseInt(key, 10);
                if (!Number.isFinite(numeric) || numeric === 0) return fallback;

                const parts = Object.entries(dictionary)
                    .map(([k, label]) => ({ num: parseInt(k, 10), label }))
                    .filter((entry) => Number.isFinite(entry.num) && entry.num > 0 && (numeric & entry.num) === entry.num)
                    .sort((a, b) => a.num - b.num)
                    .map((entry) => entry.label)
                    .filter(Boolean);

                if (parts.length > 0) {
                    return parts.join(', ');
                }

                return fallback;
            };

            function normalizeBoolean(value) {
                if (value === null || value === undefined) return null;
                if (typeof value === 'boolean') return value;

                if (typeof value === 'number') {
                    if (value === 1) return true;
                    if (value === 0) return false;
                }

                const normalized = String(value).trim().toLowerCase();
                if (['true', 'yes', 'y', '1', 'discontinued', 'retired', 'wycofana', 'wycofane', 'wycofany'].includes(normalized)) {
                    return true;
                }
                if (['false', 'no', 'n', '0', 'available', 'active'].includes(normalized)) {
                    return false;
                }

                return null;
            }

            function resolveDiscontinued(paint) {
                const candidate = paint?.isDiscontinued
                    ?? paint?.discontinued
                    ?? paint?.discontinuedFromSale
                    ?? paint?.retired
                    ?? paint?.isRetired
                    ?? paint?.status;

                return normalizeBoolean(candidate);
            }

            function formatDiscontinued(value) {
                if (value === true) return localized.discontinuedYes;
                if (value === false) return localized.discontinuedNo;
                return localized.discontinuedUnknown;
            }

            function resolveBrandWebsite(brand) {
                if (!brand) return null;

                const candidate = brand.websiteUrl
                    ?? brand.websiteURL
                    ?? brand.website
                    ?? brand.url
                    ?? brand.site
                    ?? brand.homepage
                    ?? brand.link
                    ?? brand.links?.website
                    ?? brand.links?.site
                    ?? brand.links?.homepage;

                const sanitized = sanitizeUrl(candidate);
                if (!sanitized) return null;

                let label = brand.name || '';
                try {
                    const url = new URL(sanitized);
                    if (url.hostname) {
                        label = label ? `${label} (${url.hostname})` : url.hostname;
                    }
                } catch {
                    label = label || sanitized;
                }

                return { url: sanitized, label: label || sanitized };
            }

            function sanitizeUrl(value) {
                if (!value) return null;

                const raw = String(value).trim();
                if (!raw) return null;

                const prefixed = /^https?:\/\//i.test(raw) ? raw : `https://${raw}`;

                try {
                    const url = new URL(prefixed);
                    if (['http:', 'https:'].includes(url.protocol)) {
                        return url.toString();
                    }
                } catch {
                    return null;
                }

                return null;
            }

            function normalizeIdentifiers(raw) {
                if (!raw) return [];

                if (Array.isArray(raw)) {
                    return raw.map(normalizeIdentifier).filter(Boolean);
                }

                if (typeof raw === 'object') {
                    return Object.entries(raw)
                        .map(([key, value]) => normalizeIdentifier({ type: key, value }))
                        .filter(Boolean);
                }

                return [];
            }

            function normalizeIdentifier(value) {
                if (value === null || value === undefined) return null;

                if (typeof value === 'string' || typeof value === 'number') {
                    const normalized = String(value).trim();
                    return normalized ? { label: null, value: normalized } : null;
                }

                if (typeof value === 'object') {
                    const identifierValue = value.value
                        ?? value.id
                        ?? value.code
                        ?? value.codeValue
                        ?? value.identifier
                        ?? value.number
                        ?? value.slug
                        ?? value.text;

                    if (!identifierValue && identifierValue !== 0) return null;

                    const labelParts = [];

                    if (value.bottleMl !== null && value.bottleMl !== undefined) {
                        const volume = Number(value.bottleMl);
                        if (!Number.isNaN(volume)) {
                            labelParts.push(`${volume}ml`);
                        }
                    }

                    const identifierLabel = value.type
                        ?? value.name
                        ?? value.label
                        ?? value.system
                        ?? value.scope
                        ?? value.source
                        ?? value.kind
                        ?? value.key
                        ?? value.codeType;

                    if (identifierLabel) {
                        labelParts.push(String(identifierLabel));
                    }

                    return {
                        label: labelParts.length ? labelParts.join(' · ') : null,
                        value: String(identifierValue)
                    };
                }

                return null;
            }

            function parsePaint() {
                if (!rawJson) return null;
                if (typeof rawJson === 'string') {
                    try {
                        return JSON.parse(rawJson);
                    } catch (err) {
                        console.error('Failed to parse paint JSON', err);
                        return null;
                    }
                }

                return rawJson;
            }

            function formatBookmarkEndpoint(template, itemType, itemId) {
                if (!template) return '';
                return template
                    .replace('__type__', encodeURIComponent(itemType))
                    .replace('__id__', encodeURIComponent(itemId));
            }

            function resolvePaintId(paint) {
                const candidates = [
                    paint?.id,
                    paint?.paintId,
                    paint?.paintID,
                    paint?.paint?.id,
                    paint?.paint?.paintId
                ];

                for (const candidate of candidates) {
                    const parsed = Number(candidate);
                    if (Number.isFinite(parsed) && parsed > 0) {
                        return parsed;
                    }
                }

                return null;
            }

            function resolveBookmarkFromPaint(paint) {
                const bookmark = paint?.bookmark || paint?.Bookmark || paint?.savedBookmark;
                if (!bookmark) return null;

                const category = bookmark.category || bookmark.Category || {};
                const rawCategoryId = bookmark.categoryId ?? category.id ?? category.categoryId;
                const categoryId = Number(rawCategoryId);

                return {
                    categoryId: Number.isFinite(categoryId) && categoryId > 0 ? categoryId : null,
                    categoryName: bookmark.categoryName || category.name || null,
                    note: bookmark.note || ''
                };
            }

            function setupBookmarkWidget(paint) {
                if (!window.bookmarksUi) return;
                const trigger = document.querySelector(bookmarkSelectors.triggerSelector);
                if (!trigger) return;

                const itemId = resolvePaintId(paint);
                if (!itemId) {
                    trigger.classList.add('hidden');
                    return;
                }

                const endpoints = {
                    categories: bookmarkEndpoints.categories,
                    createCategory: bookmarkEndpoints.createCategory,
                    upsert: bookmarkEndpoints.upsert,
                    delete: formatBookmarkEndpoint(bookmarkEndpoints.delete, 1, itemId)
                };

                window.bookmarksUi.init({
                    ...bookmarkSelectors,
                    itemId,
                    itemType: 1,
                    initialBookmark: resolveBookmarkFromPaint(paint),
                    endpoints,
                    auth: state.auth,
                    labels: localized.bookmarks
                });
            }

            function hydrate() {
                state.paint = parsePaint();
                if (!state.paint) {
                    toggleError(true);
                    return;
                }

                setupBookmarkWidget(state.paint);

                state.voteThreadId = resolveVoteThreadId(state.paint);
                state.voteSummary = resolveVoteSummaryFromPaint(state.paint);
                if (state.voteThreadId && !state.voteSummary) {
                    fetchVoteSummary(state.voteThreadId);
                }

                render();
            }

            function render() {
                const paint = state.paint;
                const elements = {
                    brand: document.getElementById('paint-brand'),
                    name: document.getElementById('paint-name'),
                    series: document.getElementById('paint-series'),
                    description: document.getElementById('paint-description'),
                    type: document.getElementById('paint-type'),
                    sheen: document.getElementById('paint-sheen'),
                    medium: document.getElementById('paint-medium'),
                    sku: document.getElementById('paint-sku'),
                    discontinued: document.getElementById('paint-discontinued'),
                    brandWebsite: document.getElementById('paint-brand-website'),
                    identifiers: document.getElementById('paint-identifiers'),
                    tags: document.getElementById('paint-tags'),
                    swatch: document.getElementById('paint-swatch'),
                    hex: document.getElementById('paint-hex'),
                    json: document.getElementById('paint-json'),
                    error: document.getElementById('paint-error'),
                    container: document.getElementById('paint-details')
                };

                const brandName = paint?.brand?.name || paint?.brandName || '';
                const brandSlug = paint?.brand?.slug || paint?.brandSlug || state.brandSlug;
                const seriesName = paint?.series?.name || paint?.seriesName || '';
                const seriesSlug = paint?.series?.slug || paint?.seriesSlug || state.seriesSlug;
                const paintName = paint?.name || paint?.paintName || state.paintSlug || 'Untitled paint';
                const description = paint?.description || '';
                const finishRaw = paint?.sheenId ?? paint?.sheen?.id ?? paint?.sheen;
                const typeRaw = paint?.typeId ?? paint?.type?.id ?? paint?.type;
                const mediumRaw = paint?.mediumId ?? paint?.medium?.id ?? paint?.medium;
                const finishName = resolveEnumLabel(enumLabels.sheen, finishRaw, paint?.sheenName || paint?.sheen?.name || paint?.sheen || '—');
                const typeName = resolveEnumLabel(enumLabels.type, typeRaw, paint?.typeName || paint?.type?.name || paint?.type || '—');
                const mediumName = resolveEnumLabel(enumLabels.medium, mediumRaw, paint?.mediumName || paint?.medium?.name || paint?.medium || '—');
                const sku = paint?.sku || paint?.code || '—';
                const colorHex = paint?.hex || paint?.colorHex || paint?.hexCode || paint?.swatchHex || '#0f172a';
                const swatch = buildPaintSwatch(paint, colorHex, { defaultHex: '#0f172a' });
                const tags = Array.isArray(paint?.tags) ? paint.tags : [];
                const discontinued = resolveDiscontinued(paint);
                const brandWebsite = resolveBrandWebsite(paint?.brand);
                const identifiers = normalizeIdentifiers(paint?.identifiers || paint?.ids || paint?.codes || paint?.references);

                if (elements.brand) {
                    const brandLabel = `${brandName}`;
                    elements.brand.textContent = brandLabel;
                }

                if (elements.name) {
                    elements.name.textContent = paintName;
                }

                if (elements.series) {
                    const seriesLabel = `${seriesName}`;
                    elements.series.textContent = seriesLabel;
                }

                if (elements.description) {
                    elements.description.textContent = description;
                    elements.description.classList.toggle('hidden', !description);
                }

                if (elements.type) elements.type.textContent = typeName || '—';
                if (elements.sheen) elements.sheen.textContent = finishName || '—';
                if (elements.medium) elements.medium.textContent = mediumName || '—';
                if (elements.sku) elements.sku.textContent = sku || '—';

                if (elements.discontinued) elements.discontinued.textContent = formatDiscontinued(discontinued);

                if (elements.brandWebsite) {
                    if (brandWebsite?.url) {
                        const label = brandWebsite.label || brandWebsite.url;
                        elements.brandWebsite.innerHTML = `<a href="${escapeHtml(brandWebsite.url)}" target="_blank" rel="nofollow noreferrer noopener" class="text-emerald-600 hover:underline dark:text-emerald-400">${escapeHtml(label)}</a>`;
                    } else {
                        elements.brandWebsite.textContent = localized.brandWebsiteUnavailable;
                    }
                }

                if (elements.identifiers) {
                    if (!identifiers.length) {
                        elements.identifiers.textContent = localized.identifiersNone;
                    } else {
                        elements.identifiers.innerHTML = identifiers
                            .map(item => {
                                const label = item.label ? `<span class="rounded-full bg-slate-100 px-2 py-0.5 text-xs text-slate-600 dark:bg-slate-800 dark:text-slate-200">${escapeHtml(item.label)}</span>` : '';
                                const value = `<span class="font-mono text-xs text-slate-900 dark:text-slate-100">${escapeHtml(item.value)}</span>`;
                                return `<div class="flex flex-wrap items-center gap-2">${label}${value}</div>`;
                            })
                            .join('');
                    }
                }

                if (elements.tags) {
                    if (tags.length === 0) {
                        elements.tags.innerHTML = '';
                    } else {
                        elements.tags.innerHTML = tags
                            .map(tag => typeof tag === 'string' ? tag : (tag?.name || tag?.label))
                            .filter(Boolean)
                            .map(tag => `<span class="rounded-full bg-slate-100 px-2 py-0.5 text-xs text-slate-600 dark:bg-slate-800 dark:text-slate-200">${escapeHtml(tag)}</span>`)
                            .join('');
                    }
                }

                if (elements.swatch) {
                    elements.swatch.style.background = swatch.background || colorHex;
                }

                if (elements.hex) {
                    elements.hex.textContent = swatch.label || colorHex;
                }

                renderVotes();
                initializeComments(paint);

                if (elements.json) {
                    try {
                        elements.json.textContent = JSON.stringify(paint, null, 2);
                    } catch {
                        elements.json.textContent = paint?.toString?.() ?? '';
                    }
                }

                toggleError(false);
                if (elements.container) {
                    elements.container.classList.remove('hidden');
                }
            }

            function formatCommentEndpoint(template, threadId, commentId) {
                if (!template || !threadId) return null;
                let url = template.replace('__thread__', encodeURIComponent(threadId));
                if (commentId !== undefined && commentId !== null) {
                    url = url.replace('__comment__', encodeURIComponent(commentId));
                }
                return url;
            }

            function resolveVoteThreadId(paint) {
                const candidate = paint?.voteThreadId
                    ?? paint?.voteThreadID
                    ?? paint?.votesThreadId
                    ?? paint?.voteThread?.id
                    ?? paint?.voteThread?.threadId
                    ?? paint?.voteThread;

                if (candidate === null || candidate === undefined) return null;

                if (typeof candidate === 'object') {
                    const nested = candidate.id ?? candidate.threadId ?? candidate.voteThreadId;
                    const numericNested = Number(nested);
                    if (Number.isFinite(numericNested)) return numericNested;

                    if (typeof nested === 'string' && nested.trim()) {
                        const parsedNested = Number(nested);
                        return Number.isFinite(parsedNested) ? parsedNested : null;
                    }
                }

                const numeric = Number(candidate);
                return Number.isFinite(numeric) ? numeric : null;
            }

            function resolveCommentThreadId(paint) {
                const candidate = paint?.commentThreadId
                    ?? paint?.commentThreadID
                    ?? paint?.commentThread?.id
                    ?? paint?.commentThread?.threadId
                    ?? paint?.commentThread;

                if (candidate === null || candidate === undefined) return null;

                if (typeof candidate === 'object') {
                    const nested = candidate.id ?? candidate.threadId ?? candidate.commentThreadId;
                    const numericNested = Number(nested);
                    if (Number.isFinite(numericNested)) return numericNested;
                    if (typeof nested === 'string' && nested.trim()) {
                        const parsedNested = Number(nested);
                        return Number.isFinite(parsedNested) ? parsedNested : null;
                    }
                }

                const numeric = Number(candidate);
                return Number.isFinite(numeric) ? numeric : null;
            }

            function resolveCommentCountFromPaint(paint) {
                const candidate = paint?.commentCount
                    ?? paint?.commentsCount
                    ?? paint?.commentThread?.commentCount
                    ?? paint?.commentThread?.commentsCount
                    ?? paint?.commentThread?.count;

                const numeric = Number(candidate);
                return Number.isFinite(numeric) ? numeric : null;
            }

            function normalizeVoteSummary(raw, fallbackThreadId) {
                if (!raw) return { threadId: fallbackThreadId, upVotes: 0, downVotes: 0, score: 0, userVote: 0 };

                const threadId = Number(raw.threadId ?? raw.id ?? fallbackThreadId);
                const upVotes = Number(raw.upVotes ?? raw.upvotes ?? raw.up ?? raw.upCount ?? raw.ups ?? raw.upVotesCount ?? 0);
                const downVotes = Number(raw.downVotes ?? raw.downvotes ?? raw.down ?? raw.downCount ?? raw.downs ?? raw.downVotesCount ?? 0);
                const scoreRaw = raw.score ?? raw.total ?? raw.sum ?? (Number.isFinite(upVotes) && Number.isFinite(downVotes) ? upVotes - downVotes : null);
                const score = Number(scoreRaw);
                const userVoteRaw = raw.userVote ?? raw.currentUserVote ?? raw.myVote ?? raw.vote ?? raw.value;
                const userVote = Number.isFinite(Number(userVoteRaw)) ? Number(userVoteRaw) : 0;

                return {
                    threadId: Number.isFinite(threadId) ? threadId : fallbackThreadId ?? null,
                    upVotes: Number.isFinite(upVotes) ? upVotes : 0,
                    downVotes: Number.isFinite(downVotes) ? downVotes : 0,
                    score: Number.isFinite(score) ? score : 0,
                    userVote: Number.isFinite(userVote) ? userVote : 0
                };
            }

            function resolveVoteSummaryFromPaint(paint) {
                if (!paint) return null;

                const candidate = paint.voteSummary
                    ?? paint.votes
                    ?? paint.voteThread?.summary
                    ?? paint.voteThread?.votes
                    ?? paint.voteThread?.summaryDto;

                const threadId = resolveVoteThreadId(paint);
                if (!candidate) return null;

                return normalizeVoteSummary(candidate, threadId);
            }

            function formatVoteEndpoint(template, threadId) {
                if (!template || !threadId) return null;
                return template.replace('__thread__', encodeURIComponent(threadId));
            }

            async function fetchVoteSummary(threadId) {
                if (!voteEndpoints.summary || !threadId) return null;

                try {
                    const url = formatVoteEndpoint(voteEndpoints.summary, threadId);
                    if (!url) return null;

                    state.voteLoading = true;
                    const response = await fetch(url, { headers: { 'Accept': 'application/json' } });
                    if (!response.ok) {
                        throw new Error('Request failed');
                    }

                    const payload = await response.json().catch(() => null);
                    const summary = normalizeVoteSummary(payload, threadId);
                    if (summary.threadId) {
                        state.voteSummary = summary;
                    }
                    return summary;
                } catch (error) {
                    console.warn('Unable to fetch vote summary', error);
                    return null;
                } finally {
                    state.voteLoading = false;
                    renderVotes();
                }
            }

            function renderVotes() {
                const container = voteElements.container;
                if (!container) return;

                const threadId = state.voteThreadId;
                const summary = state.voteSummary;

                if (!threadId) {
                    container.hidden = true;
                    return;
                }

                const score = Number.isFinite(Number(summary?.score))
                    ? Number(summary.score)
                    : (Number(summary?.upVotes ?? 0) - Number(summary?.downVotes ?? 0));
                const userVote = Number(summary?.userVote ?? 0) || 0;

                container.hidden = false;

                if (voteElements.score) {
                    voteElements.score.textContent = Number.isFinite(score) ? score : '—';
                }

                if (voteElements.up) {
                    voteElements.up.disabled = state.voteLoading;
                    voteElements.up.classList.toggle('bg-emerald-500/20', userVote === 1);
                    voteElements.up.classList.toggle('text-emerald-600', userVote === 1);
                }

                if (voteElements.down) {
                    voteElements.down.disabled = state.voteLoading;
                    voteElements.down.classList.toggle('bg-red-500/20', userVote === -1);
                    voteElements.down.classList.toggle('text-red-600', userVote === -1);
                }
            }

            async function handleVote(value) {
                const threadId = state.voteThreadId;
                if (!threadId || !voteEndpoints.set) return;

                if (!state.auth?.isAuthenticated) {
                    if (state.auth?.loginUrl) {
                        window.location.href = state.auth.loginUrl;
                    }
                    return;
                }

                const currentVote = Number(state.voteSummary?.userVote ?? 0) || 0;
                const desiredVote = currentVote === value ? 0 : value;
                const url = formatVoteEndpoint(voteEndpoints.set, threadId);
                if (!url) return;

                state.voteLoading = true;
                renderVotes();

                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify({ value: desiredVote })
                    });

                    if (response.status === 401) {
                        if (state.auth?.loginUrl) {
                            window.location.href = state.auth.loginUrl;
                        }
                        return;
                    }

                    if (!response.ok) {
                        throw new Error('Request failed');
                    }

                    const payload = await response.json().catch(() => null);
                    state.voteSummary = normalizeVoteSummary(payload, threadId);
                } catch (error) {
                    console.error('Unable to submit vote', error);
                } finally {
                    state.voteLoading = false;
                    renderVotes();
                }
            }

            function parseJsonSafe(payload) {
                if (typeof payload !== 'string') return payload;
                try {
                    return JSON.parse(payload);
                } catch {
                    return payload;
                }
            }

            function normalizeComments(payload) {
                if (!payload) return [];
                const raw = parseJsonSafe(payload);

                if (Array.isArray(raw)) return raw;
                if (Array.isArray(raw?.items)) return raw.items;
                if (Array.isArray(raw?.data)) return raw.data;
                if (Array.isArray(raw?.results)) return raw.results;
                if (Array.isArray(raw?.comments)) return raw.comments;

                return [];
            }

            function sortComments(comments) {
                return [...comments].sort((a, b) => (getCommentDate(a) ?? 0) - (getCommentDate(b) ?? 0));
            }

            function getCommentDate(comment) {
                const raw = comment?.updatedAt
                    ?? comment?.updatedOn
                    ?? comment?.updatedDate
                    ?? comment?.createdAt
                    ?? comment?.createdOn
                    ?? comment?.created
                    ?? comment?.timestamp;

                const date = raw ? new Date(raw) : null;
                return date?.getTime?.() ?? 0;
            }

            function getCommentAuthorId(comment) {
                if (!comment) return '';
                const author = comment.author || comment.user || comment.createdBy || {};
                return comment.authorId
                    ?? comment.createdById
                    ?? author.id
                    ?? author.userId
                    ?? comment.userId
                    ?? '';
            }

            function getCommentAuthorName(comment) {
                const author = comment?.author || comment?.user || {};
                return comment?.authorName
                    ?? author.displayName
                    ?? author.name
                    ?? author.username
                    ?? author.fullName
                    ?? comment?.createdBy
                    ?? comment?.userName
                    ?? '';
            }

            function canEditComment(comment) {
                if (!state.auth.isAuthenticated) return false;
                if (comment?.canEdit === true || comment?.isEditable === true) return true;
                const authorId = getCommentAuthorId(comment);
                if (!authorId || !state.auth.userId) return false;
                return String(authorId) === String(state.auth.userId);
            }

            function renderComments() {
                if (!commentElements.list) return;
                if (!Array.isArray(state.comments)) {
                    state.comments = [];
                }

                const items = sortComments(state.comments);
                commentElements.list.innerHTML = items.map((comment, index) => renderCommentItem(comment, index)).join('');
                renderCommentGallery(items);
                updateCommentEmptyState();
            }

            function renderCommentItem(comment, index = 0) {
                const authorName = escapeHtml(getCommentAuthorName(comment) || '');
                const content = escapeHtml(comment?.content || '');
                const dateLabel = formatTimestamp(getCommentDate(comment));
                const edited = comment?.updatedAt && comment?.updatedAt !== comment?.createdAt;
                const editButton = canEditComment(comment) && comment?.id
                    ? `<button type="button" class="text-xs font-semibold text-emerald-600 transition hover:text-emerald-500" data-edit-comment="${comment.id}">${escapeHtml(localized.comments?.edit || 'Edit')}</button>`
                    : '';

                const editedBadge = edited
                    ? `<span class="ml-2 inline-flex items-center gap-1 rounded-full bg-slate-100 px-2 py-0.5 text-[10px] font-semibold uppercase tracking-wide text-slate-500 dark:bg-slate-800 dark:text-slate-200">${escapeHtml(localized.comments?.editedLabel || 'Edited')}</span>`
                    : '';

                const attachments = normalizeCommentAttachments(comment);
                const attachmentsGroup = getCommentMediaGroupId(comment, index);
                const attachmentsMarkup = attachments.length
                    ? `<div class="mt-3 space-y-2">
                            <p class="text-[11px] font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400">${escapeHtml(localized.comments?.attachmentsLabel || localized.comments?.attachments || 'Załączniki')}</p>
                            <div class="pr-1">
                                <div class="flex flex-wrap gap-3">${attachments.map((attachment, idx) => renderCommentAttachment(attachment, attachmentsGroup, idx)).join('')}</div>
                            </div>
                       </div>`
                    : '';

                return `<article class="rounded-xl border border-slate-200 bg-white/80 p-3 text-sm text-slate-700 shadow-sm dark:border-slate-800 dark:bg-slate-900/70 dark:text-slate-200">
                    <div class="flex items-start justify-between gap-3">
                        <div>
                            <p class="font-semibold text-slate-900 dark:text-white">${authorName || 'Anon'}</p>
                            <p class="text-xs text-slate-500 dark:text-slate-400">${escapeHtml(dateLabel || '')}${editedBadge}</p>
                        </div>
                        ${editButton}
                    </div>
                    <p class="mt-2 whitespace-pre-line">${content}</p>
                    ${attachmentsMarkup}
                </article>`;
            }

            const attachmentUtils = window.AttachmentUtils || {};
            const normalizeAttachments = attachmentUtils.normalizeAttachments || (() => []);
            const isImageAttachment = attachmentUtils.isImageAttachment || (() => false);
            const isVideoAttachment = attachmentUtils.isVideoAttachment || (() => false);

            function normalizeCommentAttachments(comment) {
                const raw = comment?.attachments
                    ?? comment?.files
                    ?? comment?.media
                    ?? [];

                const collection = Array.isArray(raw)
                    ? raw
                    : Array.isArray(raw?.items)
                        ? raw.items
                        : Array.isArray(raw?.data)
                            ? raw.data
                            : Array.isArray(raw?.results)
                                ? raw.results
                                : [];

                const contextId = getCommentId(comment);

                return normalizeAttachments(collection, {
                    contextId: contextId || undefined,
                    idPrefix: 'comment'
                });
            }

            function getCommentId(comment) {
                return comment?.id
                    ?? comment?.commentId
                    ?? comment?.commentID
                    ?? null;
            }

            function getCommentMediaGroupId(comment, index = 0) {
                const id = getCommentId(comment);
                if (id !== null && id !== undefined) {
                    return `comment-${id}`;
                }

                return `comment-${index}`;
            }

            function renderCommentAttachment(attachment, groupId, index = 0) {
                const name = escapeHtml(attachment.fileName || 'attachment');
                const url = escapeHtml(attachment.url || attachment.thumbnailUrl || '');
                const isImage = isImageAttachment(attachment);
                const isVideo = isVideoAttachment(attachment);
                const previewType = isVideo ? 'video' : 'image';
                const safeIndex = Number.isFinite(Number(index)) ? Number(index) : 0;
                const groupAttr = groupId
                    ? ` data-media-group="${escapeHtml(groupId)}" data-media-index="${safeIndex}"`
                    : '';

                if ((isImage || isVideo) && url) {
                    const mediaAttrs = `data-media-preview data-media-type="${previewType}" data-media-title="${name}"${groupAttr}`;
                    const previewContent = isVideo
                        ? `<div class="relative h-24 w-full overflow-hidden bg-slate-100 dark:bg-slate-900/60">
                                <div class="absolute inset-0 grid place-items-center">
                                    <span class="inline-flex h-10 w-10 items-center justify-center rounded-full bg-slate-950/70 text-white shadow-md">▶</span>
                                </div>
                                <div class="h-full w-full bg-gradient-to-br from-slate-200 to-slate-300 dark:from-slate-800 dark:to-slate-700"></div>
                           </div>`
                        : `<div class="relative h-24 w-full overflow-hidden bg-slate-100 dark:bg-slate-900/60">
                                    <img src="${url}" alt="${name}" class="h-full w-full object-cover transition duration-150 ease-out group-hover:scale-[1.02]" loading="lazy" />
                                </div>`;

                    return `<a href="${url}" ${mediaAttrs} class="group block w-32 overflow-hidden rounded-xl border border-slate-200 bg-slate-50 shadow-sm transition hover:-translate-y-0.5 hover:border-emerald-500 dark:border-slate-700 dark:bg-slate-800/40">
                                ${previewContent}
                                <p class="truncate px-3 py-2 text-[11px] font-semibold text-slate-600 dark:text-slate-200">${name}</p>
                            </a>`;
                }

                const icon = icons.attachment || '📎';
                return `<a href="${url || '#'}" class="inline-flex max-w-[240px] items-center gap-2 rounded-full border border-slate-200 bg-white/80 px-3 py-1 text-xs font-semibold text-slate-700 shadow-sm transition hover:border-emerald-500 hover:text-emerald-600 dark:border-slate-700 dark:bg-slate-900/60 dark:text-slate-200">
                            <span class="text-emerald-600 dark:text-emerald-300">${icon}</span>
                            <span class="truncate" title="${name}">${name}</span>
                        </a>`;
            }

            function renderCommentGallery(comments) {
                if (!commentElements.gallery || !commentElements.galleryGrid || !commentElements.galleryCount) return;

                const collection = Array.isArray(comments) ? comments : [];
                const seen = new Set();
                const attachments = collection.flatMap(normalizeCommentAttachments)
                    .filter(attachment => {
                        const url = attachment.url || attachment.thumbnailUrl;
                        if (!url || (!isImageAttachment(attachment) && !isVideoAttachment(attachment))) return false;
                        if (seen.has(url)) return false;
                        seen.add(url);
                        return true;
                    });

                const shouldShow = attachments.length > 0;
                commentElements.gallery.classList.toggle('hidden', !shouldShow);

                if (!shouldShow) {
                    commentElements.galleryGrid.innerHTML = '';
                    commentElements.galleryCount.textContent = '0';
                    return;
                }

                commentElements.galleryCount.textContent = attachments.length;
                const galleryGroupId = 'comment-gallery';
                commentElements.galleryGrid.innerHTML = attachments
                    .map((attachment, index) => {
                        const url = escapeHtml(attachment.url || attachment.thumbnailUrl || '');
                        const name = escapeHtml(attachment.fileName || 'attachment');
                        const mediaType = isVideoAttachment(attachment) ? 'video' : 'image';
                        const groupAttrs = `data-media-group="${galleryGroupId}" data-media-index="${index}"`;

                        if (mediaType === 'video') {
                            return `<a href="${url}" ${groupAttrs} data-media-preview data-media-type="video" data-media-title="${name}" class="group relative block overflow-hidden rounded-lg border border-slate-200 bg-gradient-to-br from-slate-800 to-slate-700 shadow-sm transition hover:-translate-y-0.5 hover:border-emerald-500 dark:border-slate-700">
                                        <div class="flex h-24 items-center justify-center">
                                            <span class="inline-flex h-12 w-12 items-center justify-center rounded-full bg-slate-950/60 text-white shadow-md">▶</span>
                                        </div>
                                        <div class="absolute inset-x-0 bottom-0 bg-gradient-to-t from-slate-950/70 to-transparent px-2 py-1 text-[11px] font-semibold text-white drop-shadow-sm">${name}</div>
                                    </a>`;
                        }

                        return `<a href="${url}" ${groupAttrs} data-media-preview data-media-type="image" data-media-title="${name}" class="group relative block overflow-hidden rounded-lg border border-slate-200 bg-white/90 shadow-sm transition hover:-translate-y-0.5 hover:border-emerald-500 dark:border-slate-700 dark:bg-slate-900/60">
                                    <img src="${url}" alt="${name}" loading="lazy" class="h-24 w-full object-cover transition duration-150 ease-out group-hover:scale-[1.02]" />
                                    <div class="absolute inset-x-0 bottom-0 bg-gradient-to-t from-slate-950/70 to-transparent px-2 py-1 text-[11px] font-semibold text-white drop-shadow-sm">${name}</div>
                                </a>`;
                    })
                    .join('');
            }

            function formatTimestamp(timestamp) {
                if (!timestamp) return '';
                const date = new Date(timestamp);
                if (Number.isNaN(date.getTime())) return '';
                return date.toLocaleString();
            }

            function toggleCommentSection(shouldShow) {
                if (commentElements.section) {
                    commentElements.section.classList.toggle('hidden', !shouldShow);
                }
            }

            function setCommentsLoading(isLoading) {
                state.commentsLoading = !!isLoading;
                if (commentElements.loading) {
                    commentElements.loading.classList.toggle('hidden', !isLoading);
                }
                if (commentElements.submit) {
                    commentElements.submit.disabled = isLoading || state.isSubmittingComment || !state.auth.isAuthenticated;
                }
                if (commentElements.input) {
                    commentElements.input.disabled = !state.auth.isAuthenticated || isLoading;
                }
            }

            function setCommentError(message) {
                state.commentError = message || '';
                if (commentElements.error) {
                    commentElements.error.textContent = message || '';
                    commentElements.error.classList.toggle('hidden', !message);
                }
            }

            function setCommentStatus(message) {
                if (commentElements.status) {
                    commentElements.status.textContent = message || '';
                    commentElements.status.classList.toggle('hidden', !message);
                }
            }

            const MAX_ATTACHMENTS = 5;
            const MAX_ATTACHMENT_BYTES = 5 * 1024 * 1024;

            function renderAttachments() {
                if (!commentElements.attachments) return;

                if (!Array.isArray(state.attachments) || state.attachments.length === 0) {
                    commentElements.attachments.innerHTML = `<span class="text-xs text-slate-500 dark:text-slate-400">${escapeHtml(localized.comments?.attachmentsEmpty || 'Brak załączników')}</span>`;
                    return;
                }

                commentElements.attachments.innerHTML = state.attachments.map((attachment, index) => {
                    const fileName = escapeHtml(attachment.fileName || 'attachment');
                    const sizeLabel = attachment.sizeLabel ? escapeHtml(attachment.sizeLabel) : '';

                    return `<span class="inline-flex items-center gap-2 rounded-full border border-slate-200 bg-white/80 px-3 py-1 text-xs font-semibold text-slate-700 shadow-sm dark:border-slate-700 dark:bg-slate-900/60 dark:text-slate-200">
                                <span class="text-emerald-600 dark:text-emerald-300">${icons.attachment}</span>
                                <span class="max-w-[160px] truncate" title="${fileName}${sizeLabel ? ` (${sizeLabel})` : ''}">${fileName}</span>
                                ${sizeLabel ? `<span class="text-[11px] font-normal text-slate-500 dark:text-slate-400">${sizeLabel}</span>` : ''}
                                <button type="button" class="rounded-full p-1 text-slate-500 transition hover:bg-slate-100 hover:text-rose-600 dark:hover:bg-slate-800" data-remove-attachment="${index}" aria-label="${escapeHtml(localized.comments?.attachmentsRemove || 'Remove attachment')}">
                                    &times;
                                </button>
                            </span>`;
                }).join('');
            }

            function formatBytes(bytes) {
                if (!Number.isFinite(bytes) || bytes <= 0) return '';
                const units = ['B', 'KB', 'MB'];
                const exponent = Math.min(Math.floor(Math.log(bytes) / Math.log(1024)), units.length - 1);
                const value = bytes / Math.pow(1024, exponent);
                return `${value.toFixed(value >= 10 ? 0 : 1)} ${units[exponent]}`;
            }

            function removeAttachment(index) {
                if (!Array.isArray(state.attachments)) return;
                state.attachments.splice(index, 1);
                renderAttachments();
            }

            function clearAttachments() {
                state.attachments = [];
                renderAttachments();
            }

            function handleAttachmentButtonClick() {
                if (commentElements.attachmentInput && !commentElements.attachmentInput.disabled) {
                    commentElements.attachmentInput.click();
                }
            }

            function handleAttachmentSelection(event) {
                const files = Array.from(event?.target?.files || []);
                if (!files.length) return;

                if (state.attachments.length >= MAX_ATTACHMENTS) {
                    setCommentStatus(localized.comments?.attachmentsLimit || 'Osiągnięto limit załączników');
                    if (commentElements.attachmentInput) {
                        commentElements.attachmentInput.value = '';
                    }
                    return;
                }

                const remainingSlots = MAX_ATTACHMENTS - state.attachments.length;
                const selectedFiles = files.slice(0, remainingSlots);

                selectedFiles.forEach(file => {
                    if (file.size > MAX_ATTACHMENT_BYTES) {
                        setCommentError(localized.comments?.attachmentsTooLarge || 'Załącznik jest zbyt duży');
                        return;
                    }

                    readFileAsBase64(file)
                        .then(content => {
                            state.attachments.push({
                                type: 1,
                                content,
                                fileName: file.name,
                                contentType: file.type || 'application/octet-stream',
                                sizeLabel: formatBytes(file.size)
                            });
                            renderAttachments();
                        })
                        .catch(() => {
                            setCommentError(localized.comments?.attachmentsReadError || 'Nie udało się odczytać załącznika');
                        });
                });

                if (files.length > selectedFiles.length) {
                    setCommentStatus(localized.comments?.attachmentsLimit || 'Osiągnięto limit załączników');
                }

                if (commentElements.attachmentInput) {
                    commentElements.attachmentInput.value = '';
                }
            }

            function readFileAsBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        const result = reader.result;
                        if (typeof result === 'string') {
                            const base64 = result.includes(',') ? result.split(',').pop() : result;
                            resolve(base64 || '');
                        } else {
                            reject(new Error('Invalid file content'));
                        }
                    };
                    reader.onerror = () => reject(reader.error || new Error('Failed to read file'));
                    reader.readAsDataURL(file);
                });
            }

            function clearCommentStatus() {
                setCommentStatus('');
            }

            function updateCommentEmptyState() {
                if (!commentElements.empty) return;
                const shouldShow = !state.commentsLoading && Array.isArray(state.comments) && state.comments.length === 0 && !state.commentError;
                commentElements.empty.classList.toggle('hidden', !shouldShow);
            }

            function updateCommentCountDisplay() {
                const rawCount = state.commentCount ?? (Array.isArray(state.comments) ? state.comments.length : 0) ?? 0;
                const count = Number(rawCount);
                if (commentElements.count) {
                    commentElements.count.textContent = Number.isFinite(count) ? count : '0';
                }
            }

            function applyCommentAuthState() {
                const isAuthenticated = !!state.auth.isAuthenticated;
                const shouldDisableAttachments = state.isSubmittingComment || !isAuthenticated || state.editingCommentId !== null;
                if (commentElements.loginNotice) {
                    commentElements.loginNotice.classList.toggle('hidden', isAuthenticated);
                }

                if (commentElements.form) {
                    commentElements.form.classList.toggle('hidden', !isAuthenticated);
                }

                if (commentElements.input) {
                    commentElements.input.disabled = !isAuthenticated;
                }

                if (commentElements.submit) {
                    commentElements.submit.textContent = isAuthenticated
                        ? @Html.Raw(JsonSerializer.Serialize(Localizer["Comments_Submit"].Value, jsonOptions))
                        : localized.comments?.loginCta || 'Log in to comment';
                    commentElements.submit.disabled = state.isSubmittingComment || !isAuthenticated;
                }

                if (commentElements.attachmentButton) {
                    commentElements.attachmentButton.disabled = shouldDisableAttachments;
                    commentElements.attachmentButton.classList.toggle('opacity-60', shouldDisableAttachments);
                }

                if (commentElements.attachmentInput) {
                    commentElements.attachmentInput.disabled = shouldDisableAttachments;
                }

                if (!isAuthenticated && commentElements.cancelEdit) {
                    commentElements.cancelEdit.classList.add('hidden');
                }
            }

            async function refreshCommentCount() {
                if (!state.commentThreadId) return;
                const url = formatCommentEndpoint(commentEndpoints.count, state.commentThreadId);
                if (!url) return;

                try {
                    const response = await fetch(url, { headers: { 'Accept': 'application/json' } });
                    if (!response.ok) return;
                    const payload = await response.text();
                    const parsed = parseJsonSafe(payload);
                    const candidate = typeof parsed === 'number'
                        ? parsed
                        : parsed?.count
                            ?? parsed?.commentsCount
                            ?? parsed?.total
                            ?? parsed?.commentCount
                            ?? parsed?.data?.count
                            ?? parsed?.data?.total
                            ?? parsed?.data?.comments
                            ?? parsed;
                    const numeric = Number(candidate);
                    if (Number.isFinite(numeric)) {
                        state.commentCount = numeric;
                        updateCommentCountDisplay();
                    }
                } catch (error) {
                    console.warn('Unable to refresh comment count', error);
                }
            }

            async function loadComments() {
                if (!state.commentThreadId) {
                    toggleCommentSection(false);
                    return;
                }

                toggleCommentSection(true);
                setCommentsLoading(true);
                setCommentError('');

                const url = formatCommentEndpoint(commentEndpoints.thread, state.commentThreadId);
                if (!url) {
                    setCommentError(localized.comments?.unavailable || 'Comments unavailable');
                    setCommentsLoading(false);
                    return;
                }

                try {
                    const response = await fetch(url, { headers: { 'Accept': 'application/json' } });
                    if (response.status === 401) {
                        state.auth.isAuthenticated = false;
                        applyCommentAuthState();
                    }

                    if (!response.ok) {
                        throw new Error('Unable to load comments');
                    }

                    const payload = await response.text();
                    state.comments = normalizeComments(payload);
                    if (state.commentCount === null || state.commentCount === undefined) {
                        state.commentCount = state.comments.length;
                    }

                    renderComments();
                    updateCommentCountDisplay();
                } catch (error) {
                    console.error(error);
                    setCommentError(localized.comments?.error || 'Unable to load comments');
                } finally {
                    setCommentsLoading(false);
                    updateCommentEmptyState();
                }
            }

            function beginEditComment(commentId) {
                if (!state.auth.isAuthenticated) {
                    redirectToLogin();
                    return;
                }

                const comment = state.comments.find(c => Number(c?.id) === Number(commentId));
                if (!comment) return;

                state.editingCommentId = commentId;
                clearAttachments();
                if (commentElements.input) {
                    commentElements.input.value = comment?.content || '';
                    commentElements.input.focus();
                }

                if (commentElements.submit) {
                    commentElements.submit.textContent = @Html.Raw(JsonSerializer.Serialize(Localizer["Comments_Update"].Value, jsonOptions));
                }

                if (commentElements.cancelEdit) {
                    commentElements.cancelEdit.classList.remove('hidden');
                }

                clearCommentStatus();
                applyCommentAuthState();
            }

            function cancelCommentEdit() {
                state.editingCommentId = null;
                if (commentElements.input) {
                    commentElements.input.value = '';
                }
                if (commentElements.submit) {
                    commentElements.submit.textContent = @Html.Raw(JsonSerializer.Serialize(Localizer["Comments_Submit"].Value, jsonOptions));
                }
                if (commentElements.cancelEdit) {
                    commentElements.cancelEdit.classList.add('hidden');
                }
                clearCommentStatus();
                clearAttachments();
                applyCommentAuthState();
            }

            function redirectToLogin() {
                if (state.auth.loginUrl) {
                    window.location.href = state.auth.loginUrl;
                }
            }

            async function handleCommentSubmit(event) {
                event.preventDefault();
                if (!state.auth.isAuthenticated) {
                    redirectToLogin();
                    return;
                }

                if (!state.commentThreadId) {
                    setCommentError(localized.comments?.unavailable || 'Comments unavailable');
                    return;
                }

                const content = commentElements.input?.value?.trim();
                if (!content) {
                    setCommentError(localized.comments?.error || 'Comment content is required');
                    return;
                }

                const isEditing = state.editingCommentId !== null;
                const url = isEditing
                    ? formatCommentEndpoint(commentEndpoints.update, state.commentThreadId, state.editingCommentId)
                    : formatCommentEndpoint(commentEndpoints.create, state.commentThreadId);

                const payload = { content };
                if (!isEditing && Array.isArray(state.attachments) && state.attachments.length) {
                    payload.attachments = state.attachments.map(attachment => ({
                        type: attachment.type ?? 1,
                        content: attachment.content,
                        fileName: attachment.fileName,
                        contentType: attachment.contentType
                    }));
                }

                if (!url) {
                    setCommentError(localized.comments?.unavailable || 'Comments unavailable');
                    return;
                }

                state.isSubmittingComment = true;
                setCommentError('');
                clearCommentStatus();
                setCommentsLoading(true);

                try {
                    const response = await fetch(url, {
                        method: isEditing ? 'PUT' : 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 401) {
                        state.auth.isAuthenticated = false;
                        applyCommentAuthState();
                        redirectToLogin();
                        return;
                    }

                    if (!response.ok) {
                        throw new Error('Failed to submit comment');
                    }

                    cancelCommentEdit();
                    if (commentElements.input) {
                        commentElements.input.value = '';
                    }
                    clearAttachments();
                    await loadComments();
                    await refreshCommentCount();
                    setCommentStatus(isEditing ? localized.comments?.updated : localized.comments?.saved);
                } catch (error) {
                    console.error(error);
                    setCommentError(localized.comments?.error || 'Unable to submit comment');
                } finally {
                    state.isSubmittingComment = false;
                    setCommentsLoading(false);
                    applyCommentAuthState();
                }
            }

            function initializeComments(paint) {
                state.commentThreadId = resolveCommentThreadId(paint);
                state.commentCount = resolveCommentCountFromPaint(paint);
                applyCommentAuthState();
                updateCommentCountDisplay();

                if (!state.commentThreadId) {
                    setCommentError(localized.comments?.unavailable || 'Comments unavailable');
                    toggleCommentSection(false);
                    return;
                }

                toggleCommentSection(true);
                loadComments();
                refreshCommentCount();
            }

            function wireCommentEvents() {
                if (commentElements.form) {
                    commentElements.form.addEventListener('submit', handleCommentSubmit);
                }

                if (commentElements.cancelEdit) {
                    commentElements.cancelEdit.addEventListener('click', cancelCommentEdit);
                }

                if (commentElements.attachmentButton) {
                    commentElements.attachmentButton.addEventListener('click', handleAttachmentButtonClick);
                }

                if (commentElements.attachmentInput) {
                    commentElements.attachmentInput.addEventListener('change', handleAttachmentSelection);
                }

                if (commentElements.attachments) {
                    commentElements.attachments.addEventListener('click', event => {
                        const target = event.target.closest('[data-remove-attachment]');
                        if (!target) return;
                        const index = Number(target.getAttribute('data-remove-attachment'));
                        if (Number.isFinite(index)) {
                            removeAttachment(index);
                        }
                    });
                }

                if (commentElements.list) {
                    commentElements.list.addEventListener('click', event => {
                        const editBtn = event.target.closest('[data-edit-comment]');
                        if (!editBtn) return;
                        const id = Number(editBtn.getAttribute('data-edit-comment'));
                        if (Number.isFinite(id)) {
                            beginEditComment(id);
                        }
                    });
                }
            }

            renderAttachments();
            applyCommentAuthState();
            wireCommentEvents();

            function escapeHtml(value) {
                if (value === null || value === undefined) {
                    return '';
                }

                return String(value)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#039;');
            }

            function toggleError(isError) {
                const errorBox = document.getElementById('paint-error');
                const container = document.getElementById('paint-details');
                if (errorBox) {
                    errorBox.classList.toggle('hidden', !isError);
                }
                if (container) {
                    container.classList.toggle('hidden', isError);
                }

                if (isError) {
                    toggleCommentSection(false);
                }
            }

            hydrate();
        })();
    </script>
}
