@using System.Collections.Generic
@using System.Linq
@using System.Text.Encodings.Web
@using System.Text.Json
@model PaintCatalog.Portal.Models.PaintsViewModel
@inject Microsoft.AspNetCore.Mvc.Localization.IViewLocalizer Localizer

@{
    ViewData["Title"] = Localizer["Page_Title"].Value;
    ViewData["MetaDescription"] = Localizer["Page_Description"].Value;

    var paintsDataEndpoint = Url.Action("Data", "Paints") ?? "/paints/data";
    var brandsEndpoint = Url.Action("Brands", "Paints") ?? "/paints/brands";
    var brandSeriesEndpoint = Url.Action("Series", "Paints") ?? "/paints/series";
    var commentCountEndpoint = Url.Action("Count", "Comments", new { threadId = "__thread__" }) ?? "/comments/__thread__/count";
    var voteSummaryEndpoint = Url.Action("Summary", "Votes") ?? "/votes/summary";
    var voteSetEndpoint = Url.Action("Set", "Votes", new { threadId = "__thread__" }) ?? "/votes/__thread__";
    var paintDetailsTemplate = PaintCatalog.Portal.Helpers.CultureHelpers.GetRouteCultureSegment() is string cultureSegment
        ? Url.RouteUrl("PaintDetailsLocalized", new { culture = cultureSegment, brandSlug = "__brand__", seriesSlug = "__series__", paintSlug = "__paint__" }) ?? "/pl/paints/__brand__/__series__/__paint__"
        : Url.RouteUrl("PaintDetails", new { brandSlug = "__brand__", seriesSlug = "__series__", paintSlug = "__paint__" }) ?? "/paints/__brand__/__series__/__paint__";

    var initialPaintsJson = string.IsNullOrWhiteSpace(Model.InitialPaintsJson)
        ? "null"
        : Model.InitialPaintsJson;

    var brandsJson = string.IsNullOrWhiteSpace(Model.BrandsJson)
        ? "null"
        : Model.BrandsJson;

    var typeLabels = Enumerable.Range(1, 10)
        .ToDictionary(i => i.ToString(), i => Localizer[$"Filters_Type_{i}"].Value);

    var finishLabels = Enumerable.Range(1, 6)
        .ToDictionary(i => i.ToString(), i => Localizer[$"Filters_Finish_{i}"].Value);

    var mediumLabels = new Dictionary<string, string>
    {
        ["1"] = Localizer["Filters_Medium_1"].Value,
        ["2"] = Localizer["Filters_Medium_2"].Value,
        ["3"] = Localizer["Filters_Medium_3"].Value,
        ["4"] = Localizer["Filters_Medium_4"].Value,
        ["5"] = Localizer["Filters_Medium_5"].Value,
        ["99"] = Localizer["Filters_Medium_99"].Value
    };

    var jsonOptions = new JsonSerializerOptions
    {
        Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping
    };

    var bootstrap = new
    {
        endpoints = new
        {
            data = paintsDataEndpoint,
            brands = brandsEndpoint,
            series = brandSeriesEndpoint,
            details = paintDetailsTemplate,
            comments = new { count = commentCountEndpoint },
            votes = new { summary = voteSummaryEndpoint, set = voteSetEndpoint }
        },
        labels = new
        {
            brand = Localizer["Card_Label_Brand"].Value,
            series = Localizer["Card_Label_Series"].Value,
            finish = Localizer["Card_Label_Finish"].Value,
            type = Localizer["Card_Label_Type"].Value,
            medium = Localizer["Card_Label_Medium"].Value,
            tags = Localizer["Card_Label_Tags"].Value,
            sku = Localizer["Card_Label_Sku"].Value,
            color = Localizer["Card_Label_Color"].Value,
            comments = Localizer["Card_Label_Comments"].Value,
            votes = new
            {
                title = Localizer["Card_Label_Votes", "Votes"].Value,
                up = Localizer["Card_Label_Vote_Up", "Upvote"].Value,
                down = Localizer["Card_Label_Vote_Down", "Downvote"].Value
            }
        },
        filters = new
        {
            allBrands = Localizer["Filters_AllBrands"].Value,
            allSeries = Localizer["Filters_AllSeries"].Value,
            activeFiltersRemove = Localizer["ActiveFilters_Remove"].Value,
            type = typeLabels,
            finish = finishLabels,
            medium = mediumLabels
        },
        pagination = new
        {
            previous = Localizer["Pagination_Previous"].Value,
            next = Localizer["Pagination_Next"].Value
        },
        auth = new
        {
            isAuthenticated = User?.Identity?.IsAuthenticated ?? false,
            loginUrl = Url.Action("Login", "Account", new { returnUrl = Context.Request.Path + Context.Request.QueryString }) ?? "/login"
        }
    };

    var bootstrapJson = JsonSerializer.Serialize(bootstrap, jsonOptions);
}

<section class="space-y-6">
    <div class="space-y-3">
        <p class="inline-flex items-center gap-2 rounded-full border border-emerald-500/60 bg-emerald-500/10 px-3 py-1 text-xs font-semibold uppercase tracking-wide text-emerald-400">
            <span class="h-2 w-2 rounded-full bg-emerald-400"></span>
            @Localizer["Hero_Badge"]
        </p>
        <div class="space-y-2">
            <h1 class="text-3xl font-semibold tracking-tight text-slate-900 dark:text-white md:text-4xl">
                @Localizer["Hero_Title"]
            </h1>
            <p class="max-w-3xl text-sm text-slate-500 dark:text-slate-300 md:text-base">
                @Localizer["Hero_Description"]
            </p>
        </div>
    </div>

    <div class="grid gap-4 text-sm text-slate-600 dark:text-slate-300 md:grid-cols-3">
        <div class="rounded-2xl border border-slate-200 bg-white/60 p-4 dark:border-slate-800 dark:bg-slate-900/60">
            <p class="text-xs uppercase tracking-wide text-emerald-500">@Localizer["Hero_Feature1_Label"]</p>
            <p class="mt-1 text-lg font-semibold text-slate-900 dark:text-white">@Localizer["Hero_Feature1_Value"]</p>
            <p class="mt-1 text-xs text-slate-500 dark:text-slate-400">@Localizer["Hero_Feature1_Description"]</p>
        </div>
        <div class="rounded-2xl border border-slate-200 bg-white/60 p-4 dark:border-slate-800 dark:bg-slate-900/60">
            <p class="text-xs uppercase tracking-wide text-emerald-500">@Localizer["Hero_Feature2_Label"]</p>
            <p class="mt-1 text-lg font-semibold text-slate-900 dark:text-white">@Localizer["Hero_Feature2_Value"]</p>
            <p class="mt-1 text-xs text-slate-500 dark:text-slate-400">@Localizer["Hero_Feature2_Description"]</p>
        </div>
        <div class="rounded-2xl border border-slate-200 bg-white/60 p-4 dark:border-slate-800 dark:bg-slate-900/60">
            <p class="text-xs uppercase tracking-wide text-emerald-500">@Localizer["Hero_Feature3_Label"]</p>
            <p class="mt-1 text-lg font-semibold text-slate-900 dark:text-white">@Localizer["Hero_Feature3_Value"]</p>
            <p class="mt-1 text-xs text-slate-500 dark:text-slate-400">@Localizer["Hero_Feature3_Description"]</p>
        </div>
    </div>
</section>

<div class="grid gap-8 lg:grid-cols-[320px_1fr]">
    <aside class="space-y-6">
        <div class="rounded-2xl border border-slate-200 bg-white/80 p-5 shadow-sm dark:border-slate-800 dark:bg-slate-900/70">
            <div class="space-y-1">
                <p class="text-sm font-semibold text-slate-900 dark:text-white">@Localizer["Filters_Title"]</p>
                <p class="text-xs text-slate-500 dark:text-slate-400">@Localizer["Filters_Subtitle"]</p>
            </div>

            <div class="mt-4 space-y-5 text-sm">
                <div>
                    <label for="paintSearch" class="text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400">
                        @Localizer["Filters_Search_Label"]
                    </label>
                    <div class="mt-2 relative">
                        <span class="pointer-events-none absolute left-3 top-1/2 -translate-y-1/2 text-slate-400">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                                <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" />
                            </svg>
                        </span>
                        <input id="paintSearch"
                               type="search"
                               autocomplete="off"
                               placeholder="@Localizer["Filters_Search_Placeholder"]"
                               class="w-full rounded-xl border border-slate-300 bg-white/80 py-2 pl-9 pr-3 text-sm text-slate-900 placeholder:text-slate-400 focus:border-emerald-500 focus:outline-none focus:ring-2 focus:ring-emerald-500/40 dark:border-slate-700 dark:bg-slate-950/40 dark:text-slate-100" />
                    </div>
                </div>

                <div class="space-y-2">
                    <label for="brandFilter" class="text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400">
                        @Localizer["Filters_Brand_Label"]
                    </label>
                    <select id="brandFilter" class="w-full rounded-xl border border-slate-300 bg-white/80 px-3 py-2 text-sm text-slate-900 focus:border-emerald-500 focus:outline-none focus:ring-2 focus:ring-emerald-500/40 dark:border-slate-700 dark:bg-slate-900/80 dark:text-slate-100">
                        <option value="">@Localizer["Filters_AllBrands"]</option>
                    </select>
                </div>

                <div class="space-y-2">
                    <label for="seriesFilter" class="text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400">
                        @Localizer["Filters_Series_Label"]
                    </label>
                    <select id="seriesFilter" class="w-full rounded-xl border border-slate-300 bg-white/80 px-3 py-2 text-sm text-slate-900 focus:border-emerald-500 focus:outline-none focus:ring-2 focus:ring-emerald-500/40 dark:border-slate-700 dark:bg-slate-900/80 dark:text-slate-100" disabled>
                        <option value="">@Localizer["Filters_AllSeries"]</option>
                    </select>
                </div>

                <div class="space-y-2">
                    <label for="typeFilter" class="text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400">
                        @Localizer["Filters_Type_Label"]
                    </label>
                    <select id="typeFilter" class="w-full rounded-xl border border-slate-300 bg-white/80 px-3 py-2 text-sm text-slate-900 focus:border-emerald-500 focus:outline-none focus:ring-2 focus:ring-emerald-500/40 dark:border-slate-700 dark:bg-slate-900/80 dark:text-slate-100">
                        <option value="">@Localizer["Filters_Type_All"]</option>
                        @foreach (var pair in typeLabels)
                        {
                            <option value="@pair.Key">@pair.Value</option>
                        }
                    </select>
                </div>

                <div class="space-y-2">
                    <label for="finishFilter" class="text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400">
                        @Localizer["Filters_Finish_Label"]
                    </label>
                    <select id="finishFilter" class="w-full rounded-xl border border-slate-300 bg-white/80 px-3 py-2 text-sm text-slate-900 focus:border-emerald-500 focus:outline-none focus:ring-2 focus:ring-emerald-500/40 dark:border-slate-700 dark:bg-slate-900/80 dark:text-slate-100">
                        <option value="">@Localizer["Filters_Finish_All"]</option>
                        @foreach (var pair in finishLabels)
                        {
                            <option value="@pair.Key">@pair.Value</option>
                        }
                    </select>
                </div>

                <div class="space-y-2">
                    <label for="mediumFilter" class="text-xs font-semibold uppercase tracking-wide text-slate-500 dark:text-slate-400">
                        @Localizer["Filters_Medium_Label"]
                    </label>
                    <select id="mediumFilter" class="w-full rounded-xl border border-slate-300 bg-white/80 px-3 py-2 text-sm text-slate-900 focus:border-emerald-500 focus:outline-none focus:ring-2 focus:ring-emerald-500/40 dark:border-slate-700 dark:bg-slate-900/80 dark:text-slate-100">
                        <option value="">@Localizer["Filters_Medium_All"]</option>
                        @foreach (var pair in mediumLabels)
                        {
                            <option value="@pair.Key">@pair.Value</option>
                        }
                    </select>
                </div>

                <button id="clearFiltersBtn" type="button" class="w-full rounded-xl border border-slate-300 px-3 py-2 text-sm font-semibold text-slate-700 transition hover:border-emerald-500 hover:text-emerald-600 dark:border-slate-700 dark:text-slate-200">
                    @Localizer["Filters_Clear"]
                </button>
            </div>
        </div>
    </aside>

    <section class="space-y-6">
        <div class="flex flex-wrap items-center gap-4 rounded-2xl border border-slate-200 bg-white/80 p-4 text-sm dark:border-slate-800 dark:bg-slate-900/70">
            <div>
                <p id="paintStats"
                   data-template="@Localizer["Stats_Template", "{0}", "{1}", "{2}"]"
                   data-empty="@Localizer["Stats_Fallback"]"
                   class="font-semibold text-slate-900 dark:text-white">
                    @Localizer["Stats_Fallback"]
                </p>
                <p class="text-xs text-slate-500 dark:text-slate-400">@Localizer["Stats_Subtitle"]</p>
            </div>
            <div class="ml-auto flex items-center gap-2 text-xs text-slate-500 dark:text-slate-400">
                <label for="pageSizeSelect" class="font-semibold uppercase tracking-wide">@Localizer["PageSize_Label"]</label>
                <select id="pageSizeSelect" class="rounded-xl border border-slate-300 bg-white/80 px-2 py-1 text-sm text-slate-900 focus:border-emerald-500 focus:outline-none focus:ring-2 focus:ring-emerald-500/40 dark:border-slate-700 dark:bg-slate-900/80 dark:text-slate-100">
                    <option value="24">24</option>
                    <option value="48">48</option>
                </select>
            </div>
        </div>

        <div class="rounded-2xl border border-slate-200 bg-white/80 p-4 dark:border-slate-800 dark:bg-slate-900/70">
            <div class="flex items-center justify-between">
                <p class="text-sm font-semibold text-slate-900 dark:text-white">@Localizer["ActiveFilters_Title"]</p>
                <p class="text-xs text-slate-500 dark:text-slate-400">@Localizer["ActiveFilters_Subtitle"]</p>
            </div>
            <div id="activeFilters" data-empty-text="@Localizer["ActiveFilters_None"]" class="mt-3 flex flex-wrap gap-2 text-xs">
                <span class="rounded-full bg-slate-200 px-3 py-1 text-slate-600 dark:bg-slate-800/70 dark:text-slate-200">
                    @Localizer["ActiveFilters_None"]
                </span>
            </div>
        </div>

        <div id="paintLoading" class="hidden rounded-2xl border border-slate-200 bg-white/80 p-6 text-center text-sm text-slate-500 dark:border-slate-800 dark:bg-slate-900/70 dark:text-slate-300">
            <div class="flex flex-col items-center gap-2">
                <svg class="h-6 w-6 animate-spin text-emerald-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 0 1 8-8v4a4 4 0 0 0-4 4H4z"></path>
                </svg>
                <p>@Localizer["Status_Loading"]</p>
            </div>
        </div>

        <div id="paintError" class="hidden rounded-2xl border border-red-200 bg-red-50/80 p-6 text-sm text-red-800 dark:border-red-800 dark:bg-red-950/30 dark:text-red-200">
            <p class="text-base font-semibold">@Localizer["Status_Error_Title"]</p>
            <p class="mt-1 text-xs">@Localizer["Status_Error_Description"]</p>
        </div>

        <div id="paintEmpty" class="hidden rounded-2xl border border-slate-200 bg-white/80 p-6 text-center text-sm text-slate-500 dark:border-slate-800 dark:bg-slate-900/70 dark:text-slate-300">
            <p class="text-base font-semibold text-slate-900 dark:text-white">@Localizer["Status_Empty_Title"]</p>
            <p class="mt-1 text-xs">@Localizer["Status_Empty_Description"]</p>
        </div>

        <div id="paintResults" class="grid gap-4 sm:grid-cols-2 xl:grid-cols-3"></div>

        <div id="paintPagination" class="hidden items-center justify-between gap-3 rounded-2xl border border-slate-200 bg-white/80 p-4 text-sm dark:border-slate-800 dark:bg-slate-900/70">
            <button id="prevPageBtn" type="button" class="flex items-center gap-2 rounded-xl border border-slate-300 px-3 py-2 text-sm font-medium text-slate-600 transition hover:border-emerald-500 hover:text-emerald-600 disabled:opacity-50 disabled:hover:border-slate-300 dark:border-slate-700 dark:text-slate-200">
                <span aria-hidden="true">←</span>
                @Localizer["Pagination_Previous"]
            </button>
            <p id="paginationInfo" class="text-xs text-slate-500 dark:text-slate-400"></p>
            <button id="nextPageBtn" type="button" class="flex items-center gap-2 rounded-xl border border-slate-300 px-3 py-2 text-sm font-medium text-slate-600 transition hover:border-emerald-500 hover:text-emerald-600 disabled:opacity-50 disabled:hover:border-slate-300 dark:border-slate-700 dark:text-slate-200">
                @Localizer["Pagination_Next"]
                <span aria-hidden="true">→</span>
            </button>
        </div>
    </section>
</div>

@section Scripts {
    <script src="~/js/paint-swatch.js"></script>
    <script>
        window.__PAINTS_DATA = {
            config: @Html.Raw(bootstrapJson),
            initialPaints: @Html.Raw(initialPaintsJson),
            brands: @Html.Raw(brandsJson)
        };

        document.addEventListener('DOMContentLoaded', () => {
            const bootstrap = window.__PAINTS_DATA || {};
            const config = bootstrap.config || {};
            const labels = config.labels || {};
            const filterDictionaries = config.filters || {};
            const endpoints = config.endpoints || {};
            const commentEndpoints = endpoints.comments || {};
            const voteEndpoints = endpoints.votes || {};
            const auth = config.auth || {};
            const initialQueryString = window.location?.search || '';
            const initialQueryParams = new URLSearchParams(initialQueryString);
            const hasInitialQueryParams = Array.from(initialQueryParams.keys()).length > 0;
            const DEFAULT_PAGE = 1;
            const DEFAULT_PAGE_SIZE = 24;
            const swatchUtils = window.paintSwatchUtils || {};
            const normalizeHex = swatchUtils.normalizeHex || (value => {
                if (!value) return null;
                const hex = String(value).trim();
                if (!hex) return null;
                return hex.startsWith('#') ? hex : `#${hex}`;
            });
            const buildPaintSwatch = swatchUtils.buildPaintSwatch || ((paint, fallbackHex, options = {}) => {
                const hex = normalizeHex(options.defaultHex) || normalizeHex(fallbackHex) || '#475569';
                return { background: hex, label: hex };
            });
            const getIconMarkup = (id, fallback = '') => {
                try {
                    const markup = window.appIcons?.get?.(id)
                        || document.getElementById(id)?.innerHTML?.trim();
                    return markup || fallback;
                } catch (_) {
                    return fallback;
                }
            };
            const commentIcon = getIconMarkup('icon-comment', '<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" aria-hidden="true"><path stroke-linecap="round" stroke-linejoin="round" d="M20.25 13.5c0 1.682-.5 3.256-1.368 4.59-.316.5-.102 1.159.383 1.488.554.374.845 1 .699 1.641a1.678 1.678 0 0 1-1.148 1.215c-1.046.323-2.226-.057-2.968-.92a8.73 8.73 0 0 1-1.182-1.868c-.396-.8-1.289-1.246-2.175-1.014a8.42 8.42 0 0 1-2.665.259c-3.958-.343-7.151-3.54-7.49-7.501C1.91 6.22 6.16 2.25 11.22 2.25c5.059 0 9.03 4.162 9.03 9.3Z" /><path stroke-linecap="round" stroke-linejoin="round" d="M8.25 10.125h.007m3.743 0H12m3.743 0h.007" /></svg>');
            const resolveEnumLabel = (dictionary, rawValue, fallback) => {
                if (!dictionary) return fallback;

                let value = rawValue;
                if (value && typeof value === 'object') {
                    value = value.id ?? value.value ?? value.type ?? value.finish ?? value.medium;
                }

                if (value === null || value === undefined) return fallback;

                const key = String(value);
                return dictionary[key] || fallback;
            };

                const state = {
                    filters: {
                    brandId: null,
                    seriesId: null,
                    type: null,
                    finish: null,
                    medium: null,
                    search: ''
                },
                pagination: {
                    page: DEFAULT_PAGE,
                    pageSize: DEFAULT_PAGE_SIZE
                },
                total: 0,
                items: [],
                brands: normalizeBrandPayload(bootstrap.brands),
                brandSeries: {},
                loading: false,
                commentCounts: {},
                fetchedCommentThreads: new Set(),
                pendingCommentThreads: new Set(),
                voteSummaries: {},
                fetchedVoteThreads: new Set(),
                pendingVoteThreads: new Set()
            };

            primeBrandSeriesCacheFromBrands(state.brands);

            const elements = {
                searchInput: document.getElementById('paintSearch'),
                brandSelect: document.getElementById('brandFilter'),
                seriesSelect: document.getElementById('seriesFilter'),
                typeSelect: document.getElementById('typeFilter'),
                finishSelect: document.getElementById('finishFilter'),
                mediumSelect: document.getElementById('mediumFilter'),
                clearFiltersBtn: document.getElementById('clearFiltersBtn'),
                pageSizeSelect: document.getElementById('pageSizeSelect'),
                stats: document.getElementById('paintStats'),
                activeFilters: document.getElementById('activeFilters'),
                loading: document.getElementById('paintLoading'),
                error: document.getElementById('paintError'),
                empty: document.getElementById('paintEmpty'),
                results: document.getElementById('paintResults'),
                pagination: document.getElementById('paintPagination'),
                paginationInfo: document.getElementById('paginationInfo'),
                prevPageBtn: document.getElementById('prevPageBtn'),
                nextPageBtn: document.getElementById('nextPageBtn')
            };

            hydrateFromApiResponse(state, bootstrap.initialPaints);
            applyQueryParamsToState(initialQueryParams);
            populateBrandOptions();
            populateSeriesOptions();
            fetchSeriesForSelectedBrand();
            syncFormControlsWithState();
            renderAll();
            wireEvents();
            fetchBrands();

            if (!state.items.length || hasInitialQueryParams) {
                fetchPaints();
            }

            window.addEventListener('popstate', () => {
                const params = new URLSearchParams(window.location?.search || '');
                applyQueryParamsToState(params);
                populateSeriesOptions();
                fetchSeriesForSelectedBrand();
                syncFormControlsWithState();
                fetchPaints();
            });

            async function fetchPaints() {
                if (!endpoints.data) {
                    console.warn('Missing paints endpoint');
                    return;
                }

                const params = buildQueryParamsFromState();
                updateUrlFromState(params);

                toggleLoading(true);

                try {
                    const response = await fetch(`${endpoints.data}?${params.toString()}`, {
                        headers: {
                            'Accept': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        throw new Error('Request failed');
                    }

                    const payload = await response.json();
                    hydrateFromApiResponse(state, payload);
                    if (elements.error) {
                        elements.error.classList.add('hidden');
                    }
                } catch (error) {
                    console.error('Unable to fetch paints', error);
                    if (elements.error) {
                        elements.error.classList.remove('hidden');
                    }
                } finally {
                    toggleLoading(false);
                    renderAll();
                }
            }

            async function fetchBrands() {
                if (!endpoints.brands) {
                    console.warn('Missing brands endpoint');
                    return;
                }

                try {
                    const response = await fetch(endpoints.brands, {
                        headers: {
                            'Accept': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        throw new Error('Request failed');
                    }

                    const payload = await response.json();
                    state.brands = normalizeBrandPayload(payload);
                    primeBrandSeriesCacheFromBrands(state.brands);
                    populateBrandOptions();
                    populateSeriesOptions();
                    syncFormControlsWithState();
                } catch (error) {
                    console.error('Unable to fetch brands', error);
                }
            }

            async function fetchSeriesForSelectedBrand() {
                if (!endpoints.series) {
                    return;
                }

                const brandId = state.filters.brandId;
                if (!brandId) {
                    return;
                }

                const brand = state.brands.find(b => Number(b?.id) === Number(brandId));
                const brandSlug = brand?.slug;
                if (!brandSlug) {
                    return;
                }

                if (Array.isArray(state.brandSeries[brandSlug]) && state.brandSeries[brandSlug].length > 0) {
                    return;
                }

                try {
                    const url = `${endpoints.series}?brandSlug=${encodeURIComponent(brandSlug)}`;
                    const response = await fetch(url, {
                        headers: {
                            'Accept': 'application/json'
                        }
                    });

                    if (!response.ok) {
                        throw new Error('Request failed');
                    }

                    const payload = await response.json();
                    const normalized = normalizeSeriesPayload(payload);
                    state.brandSeries[brandSlug] = normalized;
                    populateSeriesOptions();
                    syncFormControlsWithState();
                } catch (error) {
                    console.error('Unable to fetch series for brand', error);
                }
            }

            function hydrateFromApiResponse(targetState, payload) {
                const normalized = normalizePaintPayload(payload, targetState.pagination.pageSize);
                targetState.items = normalized.items;
                targetState.total = normalized.total;
                targetState.pagination.page = normalized.page;
                targetState.pagination.pageSize = normalized.pageSize;
                primeCommentCounts(targetState.items);
                primeVoteSummaries(targetState.items);
                fetchVoteSummariesForPaints(targetState.items);

                if (elements.pageSizeSelect) {
                    elements.pageSizeSelect.value = String(targetState.pagination.pageSize);
                }
            }

            function normalizePaintPayload(payload, fallbackPageSize) {
                if (!payload) {
                    return { items: [], total: 0, page: 1, pageSize: fallbackPageSize };
                }

                let raw = payload;
                if (typeof raw === 'string') {
                    try {
                        raw = JSON.parse(raw);
                    } catch (error) {
                        console.warn('Unable to parse paints payload', error);
                        raw = null;
                    }
                }

                if (!raw) {
                    return { items: [], total: 0, page: 1, pageSize: fallbackPageSize };
                }

                const items = Array.isArray(raw.items)
                    ? raw.items
                    : Array.isArray(raw.data)
                        ? raw.data
                        : Array.isArray(raw.results)
                            ? raw.results
                            : Array.isArray(raw.paints)
                                ? raw.paints
                                : [];

                const total = Number.isFinite(raw.total)
                    ? raw.total
                    : Number.isFinite(raw.count)
                        ? raw.count
                        : items.length;

                const page = Number.isFinite(raw.page)
                    ? raw.page
                    : Number.isFinite(raw.currentPage)
                        ? raw.currentPage
                        : 1;

                const pageSize = Number.isFinite(raw.pageSize)
                    ? raw.pageSize
                    : Number.isFinite(raw.perPage)
                        ? raw.perPage
                        : (items.length > 0 ? items.length : fallbackPageSize);

                return { items, total, page, pageSize };
            }

            function normalizeBrandPayload(payload) {
                if (!payload) return [];
                let raw = payload;
                if (typeof raw === 'string') {
                    try {
                        raw = JSON.parse(raw);
                    } catch (error) {
                        console.warn('Unable to parse brands payload', error);
                        return [];
                    }
                }

                if (Array.isArray(raw)) {
                    return raw;
                }

                if (Array.isArray(raw.items)) return raw.items;
                if (Array.isArray(raw.data)) return raw.data;

                return [];
            }

            function normalizeSeriesPayload(payload) {
                if (!payload) return [];

                let raw = payload;
                if (typeof raw === 'string') {
                    try {
                        raw = JSON.parse(raw);
                    } catch (error) {
                        console.warn('Unable to parse series payload', error);
                        return [];
                    }
                }

                if (Array.isArray(raw)) return raw;
                if (Array.isArray(raw.items)) return raw.items;
                if (Array.isArray(raw.data)) return raw.data;

                return [];
            }

            function primeBrandSeriesCacheFromBrands(brands) {
                if (!Array.isArray(brands)) return;

                brands.forEach(brand => {
                    if (!brand?.slug || !Array.isArray(brand.series) || brand.series.length === 0) {
                        return;
                    }

                    if (!Array.isArray(state.brandSeries[brand.slug])) {
                        state.brandSeries[brand.slug] = brand.series;
                    }
                });
            }

            function populateBrandOptions() {
                const select = elements.brandSelect;
                if (!select) return;

                select.innerHTML = '';
                const placeholderOption = document.createElement('option');
                placeholderOption.value = '';
                placeholderOption.textContent = filterDictionaries.allBrands || 'All brands';
                select.appendChild(placeholderOption);

                if (state.brands.length === 0) {
                    select.disabled = true;
                    select.value = '';
                    return;
                }

                state.brands.forEach(brand => {
                    if (!brand) return;
                    const option = document.createElement('option');
                    option.value = String(brand.id ?? '');
                    option.textContent = brand.name ?? `#${brand.id}`;
                    select.appendChild(option);
                });

                select.disabled = false;
                select.value = state.filters.brandId !== null ? String(state.filters.brandId) : '';
            }

            function populateSeriesOptions() {
                const select = elements.seriesSelect;
                if (!select) return;

                select.innerHTML = '';
                const placeholderOption = document.createElement('option');
                placeholderOption.value = '';
                placeholderOption.textContent = filterDictionaries.allSeries || 'All series';
                select.appendChild(placeholderOption);

                const brandId = state.filters.brandId;
                if (!brandId) {
                    select.disabled = true;
                    select.value = '';
                    state.filters.seriesId = null;
                    return;
                }

                const numericBrandId = Number(brandId);
                const brand = state.brands.find(b => Number(b?.id) === numericBrandId);
                const brandSlug = brand?.slug;
                const seriesList = brandSlug && Array.isArray(state.brandSeries[brandSlug])
                    ? state.brandSeries[brandSlug]
                    : Array.isArray(brand?.series)
                        ? brand.series
                        : [];

                if (seriesList.length === 0) {
                    select.disabled = true;
                    select.value = '';
                    state.filters.seriesId = null;
                    if (brandSlug) {
                        fetchSeriesForSelectedBrand();
                    }
                    return;
                }

                seriesList.forEach(series => {
                    if (!series) return;
                    const option = document.createElement('option');
                    option.value = String(series.id ?? '');
                    option.textContent = series.name ?? `#${series.id}`;
                    select.appendChild(option);
                });

                select.disabled = false;
                select.value = state.filters.seriesId !== null ? String(state.filters.seriesId) : '';
            }

            function wireEvents() {
                if (elements.searchInput) {
                    const debounced = debounce(value => {
                        state.filters.search = value.trim();
                        state.pagination.page = 1;
                        fetchPaints();
                    }, 400);

                    elements.searchInput.addEventListener('input', event => {
                        debounced(event.target.value || '');
                    });
                }

                if (elements.brandSelect) {
                    elements.brandSelect.addEventListener('change', event => {
                        const value = event.target.value;
                        state.filters.brandId = value ? Number(value) : null;
                        state.filters.seriesId = null;
                        populateSeriesOptions();
                        fetchSeriesForSelectedBrand();
                        state.pagination.page = 1;
                        fetchPaints();
                    });
                }

                if (elements.seriesSelect) {
                    elements.seriesSelect.addEventListener('change', event => {
                        const value = event.target.value;
                        state.filters.seriesId = value ? Number(value) : null;
                        state.pagination.page = 1;
                        fetchPaints();
                    });
                }

                if (elements.typeSelect) {
                    elements.typeSelect.addEventListener('change', event => {
                        const value = event.target.value;
                        state.filters.type = value ? Number(value) : null;
                        state.pagination.page = 1;
                        fetchPaints();
                    });
                }

                if (elements.finishSelect) {
                    elements.finishSelect.addEventListener('change', event => {
                        const value = event.target.value;
                        state.filters.finish = value ? Number(value) : null;
                        state.pagination.page = 1;
                        fetchPaints();
                    });
                }

                if (elements.mediumSelect) {
                    elements.mediumSelect.addEventListener('change', event => {
                        const value = event.target.value;
                        state.filters.medium = value ? Number(value) : null;
                        state.pagination.page = 1;
                        fetchPaints();
                    });
                }

                if (elements.clearFiltersBtn) {
                    elements.clearFiltersBtn.addEventListener('click', () => {
                        elements.brandSelect.value = '';
                        elements.seriesSelect.value = '';
                        elements.typeSelect.value = '';
                        elements.finishSelect.value = '';
                        elements.mediumSelect.value = '';
                        if (elements.searchInput) {
                            elements.searchInput.value = '';
                        }

                        state.filters = {
                            brandId: null,
                            seriesId: null,
                            type: null,
                            finish: null,
                            medium: null,
                            search: ''
                        };

                        populateSeriesOptions();
                        state.pagination.page = 1;
                        fetchPaints();
                    });
                }

                if (elements.pageSizeSelect) {
                    elements.pageSizeSelect.addEventListener('change', event => {
                        const value = Number(event.target.value) || 24;
                        state.pagination.pageSize = value;
                        state.pagination.page = 1;
                        fetchPaints();
                    });
                }

                if (elements.prevPageBtn) {
                    elements.prevPageBtn.addEventListener('click', () => {
                        if (state.pagination.page <= 1) return;
                        state.pagination.page -= 1;
                        fetchPaints();
                    });
                }

                if (elements.nextPageBtn) {
                    elements.nextPageBtn.addEventListener('click', () => {
                        const totalPages = Math.max(1, Math.ceil(state.total / state.pagination.pageSize));
                        if (state.pagination.page >= totalPages) return;
                        state.pagination.page += 1;
                        fetchPaints();
                    });
                }

                if (elements.results) {
                    elements.results.addEventListener('click', event => {
                        const button = event.target.closest('[data-vote-action]');
                        if (!button) return;

                        const threadId = Number(button.dataset.threadId);
                        if (!Number.isFinite(threadId)) return;

                        const action = button.dataset.voteAction;
                        const summary = getVoteSummary(threadId) || {};
                        const currentVote = Number(summary.userVote ?? 0) || 0;
                        const desired = action === 'up' ? 1 : -1;
                        const nextVote = currentVote === desired ? 0 : desired;
                        submitVote(threadId, nextVote);
                    });
                }
            }

            function renderAll() {
                updateStats();
                renderActiveFilters();
                renderPaintCards();
                renderPagination();
                renderEmptyState();
            }

            function applyQueryParamsToState(params) {
                if (!params) return;

                state.filters = {
                    brandId: null,
                    seriesId: null,
                    type: null,
                    finish: null,
                    medium: null,
                    search: ''
                };

                state.pagination.page = DEFAULT_PAGE;
                state.pagination.pageSize = DEFAULT_PAGE_SIZE;

                const brandId = parseNumericParam(params.get('brandId'));
                if (brandId !== null) {
                    state.filters.brandId = brandId;
                }

                const seriesId = parseNumericParam(params.get('seriesId'));
                if (seriesId !== null) {
                    state.filters.seriesId = seriesId;
                }

                const type = parseNumericParam(params.get('type'));
                if (type !== null) {
                    state.filters.type = type;
                }

                const finish = parseNumericParam(params.get('finish'));
                if (finish !== null) {
                    state.filters.finish = finish;
                }

                const medium = parseNumericParam(params.get('medium'));
                if (medium !== null) {
                    state.filters.medium = medium;
                }

                const search = params.get('search');
                if (typeof search === 'string') {
                    state.filters.search = search.trim();
                }

                const page = parseNumericParam(params.get('page'));
                if (page !== null && page > 0) {
                    state.pagination.page = page;
                }

                const pageSize = parseNumericParam(params.get('pageSize'));
                if (pageSize !== null && pageSize > 0) {
                    state.pagination.pageSize = pageSize;
                }
            }

            function syncFormControlsWithState() {
                if (elements.searchInput) {
                    elements.searchInput.value = state.filters.search || '';
                }

                if (elements.brandSelect) {
                    elements.brandSelect.value = state.filters.brandId !== null ? String(state.filters.brandId) : '';
                }

                if (elements.seriesSelect) {
                    elements.seriesSelect.value = state.filters.seriesId !== null ? String(state.filters.seriesId) : '';
                }

                if (elements.typeSelect) {
                    elements.typeSelect.value = state.filters.type !== null ? String(state.filters.type) : '';
                }

                if (elements.finishSelect) {
                    elements.finishSelect.value = state.filters.finish !== null ? String(state.filters.finish) : '';
                }

                if (elements.mediumSelect) {
                    elements.mediumSelect.value = state.filters.medium !== null ? String(state.filters.medium) : '';
                }

                if (elements.pageSizeSelect) {
                    elements.pageSizeSelect.value = String(state.pagination.pageSize);
                }
            }

            function buildQueryParamsFromState() {
                const params = new URLSearchParams();
                const { filters, pagination } = state;

                if (filters.brandId !== null) params.append('brandId', filters.brandId);
                if (filters.seriesId !== null) params.append('seriesId', filters.seriesId);
                if (filters.type !== null) params.append('type', filters.type);
                if (filters.finish !== null) params.append('finish', filters.finish);
                if (filters.medium !== null) params.append('medium', filters.medium);
                if (filters.search) params.append('search', filters.search);
                if (pagination.page && pagination.page !== DEFAULT_PAGE) {
                    params.append('page', pagination.page);
                }

                if (pagination.pageSize && pagination.pageSize !== DEFAULT_PAGE_SIZE) {
                    params.append('pageSize', pagination.pageSize);
                }

                return params;
            }

            function updateUrlFromState(providedParams) {
                if (!window?.history?.replaceState) return;
                const params = providedParams || buildQueryParamsFromState();
                const queryString = params.toString();
                const basePath = window.location.pathname || '';
                const newUrl = queryString ? `${basePath}?${queryString}` : basePath;
                const current = `${window.location.pathname}${window.location.search}`;

                if (current !== newUrl) {
                    window.history.replaceState(window.history.state, '', newUrl);
                }
            }

            function parseNumericParam(value) {
                if (value === null || value === undefined || value === '') {
                    return null;
                }

                const parsed = Number(value);
                return Number.isFinite(parsed) ? parsed : null;
            }

            function updateStats() {
                if (!elements.stats) return;
                const template = elements.stats.dataset.template || '';
                const emptyCopy = elements.stats.dataset.empty || '';

                if (!state.items.length) {
                    elements.stats.textContent = emptyCopy;
                    return;
                }

                const start = (state.pagination.page - 1) * state.pagination.pageSize + 1;
                const end = Math.min(state.total, state.pagination.page * state.pagination.pageSize);
                const formatted = template
                    .replace('{0}', start)
                    .replace('{1}', end)
                    .replace('{2}', state.total);

                elements.stats.textContent = formatted;
            }

            function renderActiveFilters() {
                const container = elements.activeFilters;
                if (!container) return;

                const removalLabel = filterDictionaries?.activeFiltersRemove || 'Remove filter';
                container.innerHTML = '';
                const active = [];

                if (state.filters.brandId) {
                    const brand = state.brands.find(b => Number(b?.id) === Number(state.filters.brandId));
                    if (brand?.name) {
                        active.push({
                            key: 'brand',
                            label: `${labels.brand || 'Brand'}: ${brand.name}`,
                            onRemove: () => {
                                state.filters.brandId = null;
                                state.filters.seriesId = null;
                                populateSeriesOptions();
                            }
                        });
                    }
                }

                if (state.filters.seriesId) {
                    const brand = state.brands.find(b => Number(b?.id) === Number(state.filters.brandId));
                    const brandSlug = brand?.slug;
                    const seriesList = brandSlug && Array.isArray(state.brandSeries[brandSlug])
                        ? state.brandSeries[brandSlug]
                        : Array.isArray(brand?.series)
                            ? brand.series
                            : [];
                    const series = seriesList.find(s => Number(s?.id) === Number(state.filters.seriesId));
                    if (series?.name) {
                        active.push({
                            key: 'series',
                            label: `${labels.series || 'Series'}: ${series.name}`,
                            onRemove: () => {
                                state.filters.seriesId = null;
                                populateSeriesOptions();
                            }
                        });
                    }
                }

                if (state.filters.type) {
                    const label = filterDictionaries.type?.[String(state.filters.type)] || `Type ${state.filters.type}`;
                    active.push({
                        key: 'type',
                        label: `${labels.type || 'Type'}: ${label}`,
                        onRemove: () => { state.filters.type = null; }
                    });
                }

                if (state.filters.finish) {
                    const label = filterDictionaries.finish?.[String(state.filters.finish)] || `Finish ${state.filters.finish}`;
                    active.push({
                        key: 'finish',
                        label: `${labels.finish || 'Finish'}: ${label}`,
                        onRemove: () => { state.filters.finish = null; }
                    });
                }

                if (state.filters.medium) {
                    const label = filterDictionaries.medium?.[String(state.filters.medium)] || `Medium ${state.filters.medium}`;
                    active.push({
                        key: 'medium',
                        label: `${labels.medium || 'Medium'}: ${label}`,
                        onRemove: () => { state.filters.medium = null; }
                    });
                }

                if (state.filters.search) {
                    active.push({
                        key: 'search',
                        label: `"${state.filters.search}"`,
                        onRemove: () => { state.filters.search = ''; }
                    });
                }

                if (!active.length) {
                    const span = document.createElement('span');
                    span.className = 'rounded-full bg-slate-200 px-3 py-1 text-slate-600 dark:bg-slate-800/70 dark:text-slate-200';
                    span.textContent = container.dataset.emptyText || 'No filters';
                    container.appendChild(span);
                    return;
                }

                active.forEach(item => {
                    const pill = document.createElement('span');
                    pill.className = 'inline-flex items-center gap-2 rounded-full bg-emerald-100 px-3 py-1 text-emerald-800 dark:bg-emerald-500/20 dark:text-emerald-200';

                    const text = document.createElement('span');
                    text.textContent = item.label;
                    pill.appendChild(text);

                    if (typeof item.onRemove === 'function') {
                        const removeBtn = document.createElement('button');
                        removeBtn.type = 'button';
                        removeBtn.className = 'grid h-5 w-5 place-items-center rounded-full text-emerald-600 transition hover:bg-emerald-200 focus:outline-none focus:ring-2 focus:ring-emerald-400 dark:text-emerald-200 dark:hover:bg-emerald-500/30';
                        removeBtn.innerHTML = `<span aria-hidden="true">×</span><span class="sr-only">${removalLabel}</span>`;
                        removeBtn.addEventListener('click', () => {
                            item.onRemove();
                            state.pagination.page = 1;
                            syncFormControlsWithState();
                            renderActiveFilters();
                            fetchPaints();
                        });
                        pill.appendChild(removeBtn);
                    }

                    container.appendChild(pill);
                });
            }

            function extractCommentThreadId(paint) {
                const candidate = paint?.commentThreadId
                    ?? paint?.commentThreadID
                    ?? paint?.commentsThreadId
                    ?? paint?.commentThread?.id
                    ?? paint?.commentThread?.threadId
                    ?? paint?.commentThread;

                if (candidate === null || candidate === undefined) {
                    return null;
                }

                if (typeof candidate === 'object') {
                    const nested = candidate.id ?? candidate.threadId ?? candidate.threadID ?? candidate.commentThreadId;
                    const numericNested = Number(nested);
                    if (Number.isFinite(numericNested)) return numericNested;

                    if (typeof nested === 'string' && nested.trim()) {
                        const parsedNested = Number(nested);
                        return Number.isFinite(parsedNested) ? parsedNested : null;
                    }
                }

                const numeric = Number(candidate);
                return Number.isFinite(numeric) ? numeric : null;
            }

            function extractVoteThreadId(paint) {
                const candidate = paint?.voteThreadId
                    ?? paint?.voteThreadID
                    ?? paint?.votesThreadId
                    ?? paint?.voteThread?.id
                    ?? paint?.voteThread?.threadId
                    ?? paint?.voteThread;

                if (candidate === null || candidate === undefined) {
                    return null;
                }

                if (typeof candidate === 'object') {
                    const nested = candidate.id ?? candidate.threadId ?? candidate.voteThreadId;
                    const numericNested = Number(nested);
                    if (Number.isFinite(numericNested)) return numericNested;

                    if (typeof nested === 'string' && nested.trim()) {
                        const parsedNested = Number(nested);
                        return Number.isFinite(parsedNested) ? parsedNested : null;
                    }
                }

                const numeric = Number(candidate);
                return Number.isFinite(numeric) ? numeric : null;
            }

            function extractCommentCountFromPaint(paint) {
                const candidate = paint?.commentCount
                    ?? paint?.commentsCount
                    ?? paint?.comment_count
                    ?? paint?.comments_count
                    ?? paint?.commentThread?.commentCount
                    ?? paint?.commentThread?.commentsCount
                    ?? paint?.commentThread?.count;

                const numeric = Number(candidate);
                return Number.isFinite(numeric) ? numeric : null;
            }

            function formatCommentEndpoint(template, threadId) {
                if (!template || !threadId) return null;
                return template.replace('__thread__', encodeURIComponent(threadId));
            }

            async function fetchCommentCount(threadId) {
                if (!threadId || !commentEndpoints.count) return null;

                if (state.commentCounts[threadId] !== undefined) {
                    return state.commentCounts[threadId];
                }

                if (state.pendingCommentThreads.has(threadId) || state.fetchedCommentThreads.has(threadId)) {
                    return null;
                }

                state.pendingCommentThreads.add(threadId);

                const url = formatCommentEndpoint(commentEndpoints.count, threadId);
                if (!url) {
                    state.pendingCommentThreads.delete(threadId);
                    return null;
                }

                try {
                    const response = await fetch(url, { headers: { 'Accept': 'application/json' } });
                    if (!response.ok) return null;

                    const payload = await response.text();
                    let resolved = null;

                    try {
                        const json = JSON.parse(payload);
                        if (typeof json === 'number') {
                            resolved = json;
                        } else if (json && typeof json === 'object') {
                            const candidate = json.count
                                ?? json.comments
                                ?? json.total
                                ?? json.commentCount
                                ?? json.commentsCount
                                ?? json?.data?.commentsCount
                                ?? json?.data?.commentCount
                                ?? json?.data?.count
                                ?? json?.data?.total
                                ?? json?.data?.comments
                                ?? json?.result?.count
                                ?? json?.result?.total;

                            const numericCandidate = Number(candidate);
                            if (Number.isFinite(numericCandidate)) {
                                resolved = numericCandidate;
                            }
                        }
                    } catch {
                        const numeric = Number(payload);
                        if (Number.isFinite(numeric)) {
                            resolved = numeric;
                        }
                    }

                    if (resolved !== null) {
                        state.commentCounts[threadId] = resolved;
                        state.fetchedCommentThreads.add(threadId);
                        return resolved;
                    }
                } catch (error) {
                    console.warn('Unable to fetch comment count', error);
                } finally {
                    state.pendingCommentThreads.delete(threadId);
                }

                return null;
            }

            function primeCommentCounts(paints) {
                if (!commentEndpoints.count || !Array.isArray(paints)) return;

                const threadsToFetch = [];
                const seen = new Set();

                paints.forEach(paint => {
                    const threadId = extractCommentThreadId(paint);
                    if (!threadId || seen.has(threadId)) return;
                    seen.add(threadId);

                    const countFromPayload = extractCommentCountFromPaint(paint);
                    const hasCachedCount = state.commentCounts[threadId] !== undefined;
                    const hasFetchedCount = state.fetchedCommentThreads.has(threadId);

                    if (!hasCachedCount && countFromPayload !== null) {
                        state.commentCounts[threadId] = countFromPayload;
                    }

                    if (hasFetchedCount) {
                        return;
                    }

                    threadsToFetch.push(threadId);
                });

                threadsToFetch.forEach(threadId => {
                    fetchCommentCount(threadId).then(count => {
                        if (count !== null && count !== undefined) {
                            state.commentCounts[threadId] = count;
                            renderPaintCards();
                        }
                    });
                });
            }

            function resolveCommentCount(paint) {
                const threadId = extractCommentThreadId(paint);
                if (threadId && state.commentCounts[threadId] !== undefined) {
                    return state.commentCounts[threadId];
                }

                const fromPayload = extractCommentCountFromPaint(paint);
                if (threadId && fromPayload !== null && state.commentCounts[threadId] === undefined) {
                    state.commentCounts[threadId] = fromPayload;
                }

                if (threadId && commentEndpoints.count) {
                    fetchCommentCount(threadId).then(count => {
                        if (count !== null && count !== undefined) {
                            state.commentCounts[threadId] = count;
                            renderPaintCards();
                        }
                    });
                }

                return fromPayload;
            }

            function normalizeVoteSummary(raw, fallbackThreadId) {
                if (!raw) return { threadId: fallbackThreadId, upVotes: 0, downVotes: 0, score: 0, userVote: 0 };

                const threadId = Number(raw.threadId ?? raw.id ?? fallbackThreadId);
                const upVotes = Number(raw.upVotes ?? raw.upvotes ?? raw.up ?? raw.upCount ?? raw.ups ?? raw.upVotesCount ?? 0);
                const downVotes = Number(raw.downVotes ?? raw.downvotes ?? raw.down ?? raw.downCount ?? raw.downs ?? raw.downVotesCount ?? 0);
                const scoreRaw = raw.score ?? raw.total ?? raw.sum ?? (Number.isFinite(upVotes) && Number.isFinite(downVotes) ? upVotes - downVotes : null);
                const score = Number(scoreRaw);
                const userVoteRaw = raw.userVote ?? raw.currentUserVote ?? raw.myVote ?? raw.vote ?? raw.value;
                const userVote = Number.isFinite(Number(userVoteRaw)) ? Number(userVoteRaw) : 0;

                return {
                    threadId: Number.isFinite(threadId) ? threadId : fallbackThreadId ?? null,
                    upVotes: Number.isFinite(upVotes) ? upVotes : 0,
                    downVotes: Number.isFinite(downVotes) ? downVotes : 0,
                    score: Number.isFinite(score) ? score : 0,
                    userVote: Number.isFinite(userVote) ? userVote : 0
                };
            }

            function resolveVoteSummaryFromPaint(paint) {
                if (!paint) return null;

                const candidate = paint.voteSummary
                    ?? paint.votes
                    ?? paint.voteThread?.summary
                    ?? paint.voteThread?.votes
                    ?? paint.voteThread?.summaryDto;

                const threadId = extractVoteThreadId(paint);
                if (!candidate) return null;

                return normalizeVoteSummary(candidate, threadId);
            }

            function primeVoteSummaries(paints) {
                if (!Array.isArray(paints)) return;

                paints.forEach(paint => {
                    const threadId = extractVoteThreadId(paint);
                    if (!threadId || state.fetchedVoteThreads.has(threadId)) return;

                    const summary = resolveVoteSummaryFromPaint(paint);
                    if (summary && summary.threadId) {
                        state.voteSummaries[summary.threadId] = summary;
                        state.fetchedVoteThreads.add(summary.threadId);
                    }
                });
            }

            function formatVoteEndpoint(template, threadId) {
                if (!template || !threadId) return null;
                return template.replace('__thread__', encodeURIComponent(threadId));
            }

            async function fetchVoteSummariesForPaints(paints) {
                if (!voteEndpoints.summary || !Array.isArray(paints)) return;

                const idsToFetch = [];
                const seen = new Set();

                paints.forEach(paint => {
                    const threadId = extractVoteThreadId(paint);
                    if (!threadId || seen.has(threadId)) return;
                    seen.add(threadId);

                    if (state.fetchedVoteThreads.has(threadId) || state.pendingVoteThreads.has(threadId)) {
                        return;
                    }

                    const summary = resolveVoteSummaryFromPaint(paint);
                    if (summary && summary.threadId) {
                        state.voteSummaries[summary.threadId] = summary;
                        state.fetchedVoteThreads.add(summary.threadId);
                        return;
                    }

                    idsToFetch.push(threadId);
                });

                if (!idsToFetch.length) return;

                idsToFetch.forEach(id => state.pendingVoteThreads.add(id));

                try {
                    const query = idsToFetch.map(id => `threadIds=${encodeURIComponent(id)}`).join('&');
                    const separator = voteEndpoints.summary.includes('?') ? '&' : '?';
                    const url = `${voteEndpoints.summary}${idsToFetch.length ? separator + query : ''}`;
                    const response = await fetch(url, { headers: { 'Accept': 'application/json' } });
                    if (!response.ok) {
                        throw new Error('Request failed');
                    }

                    const payload = await response.json().catch(() => null);
                    const summaries = [];

                    if (Array.isArray(payload)) {
                        summaries.push(...payload);
                    } else if (Array.isArray(payload?.data)) {
                        summaries.push(...payload.data);
                    } else if (Array.isArray(payload?.items)) {
                        summaries.push(...payload.items);
                    } else if (payload && typeof payload === 'object') {
                        Object.entries(payload).forEach(([key, value]) => {
                            const threadId = Number(key);
                            summaries.push({ threadId, ...(typeof value === 'object' ? value : { score: value }) });
                        });
                    }

                    summaries.forEach(item => {
                        const normalized = normalizeVoteSummary(item, item.threadId);
                        if (normalized.threadId) {
                            state.voteSummaries[normalized.threadId] = normalized;
                            state.fetchedVoteThreads.add(normalized.threadId);
                        }
                    });
                } catch (error) {
                    console.warn('Unable to fetch vote summaries', error);
                } finally {
                    idsToFetch.forEach(id => state.pendingVoteThreads.delete(id));
                }
            }

            function getVoteSummary(threadId, paint) {
                if (threadId && state.voteSummaries[threadId]) {
                    return state.voteSummaries[threadId];
                }

                const summary = resolveVoteSummaryFromPaint(paint);
                if (threadId && summary && summary.threadId) {
                    state.voteSummaries[threadId] = summary;
                    return summary;
                }

                return summary;
            }

            async function submitVote(threadId, voteValue) {
                if (!voteEndpoints.set || !threadId) return;

                if (!auth.isAuthenticated) {
                    if (auth.loginUrl) {
                        window.location.href = auth.loginUrl;
                    }
                    return;
                }

                const url = formatVoteEndpoint(voteEndpoints.set, threadId);
                if (!url) return;

                state.pendingVoteThreads.add(threadId);
                renderPaintCards();

                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify({ value: voteValue })
                    });

                    if (response.status === 401) {
                        if (auth.loginUrl) {
                            window.location.href = auth.loginUrl;
                        }
                        return;
                    }

                    if (!response.ok) {
                        throw new Error('Request failed');
                    }

                    const payload = await response.json().catch(() => null);
                    const normalized = normalizeVoteSummary(payload, threadId);
                    if (normalized.threadId) {
                        state.voteSummaries[normalized.threadId] = normalized;
                        state.fetchedVoteThreads.add(normalized.threadId);
                    }
                } catch (error) {
                    console.error('Unable to submit vote', error);
                } finally {
                    state.pendingVoteThreads.delete(threadId);
                    renderPaintCards();
                }
            }

            function renderPaintCards() {
                const container = elements.results;
                if (!container) return;

                if (!state.items.length) {
                    container.innerHTML = '';
                    container.classList.add('hidden');
                    return;
                }

                container.classList.remove('hidden');
                container.innerHTML = state.items.map(createPaintCard).join('');
            }

            function createPaintCard(paint) {
                const brandName = (paint?.brand?.name) || paint?.brandName || '';
                const brandSlug = (paint?.brand?.slug) || paint?.brandSlug || paint?.brand?.urlSlug || '';
                const seriesName = (paint?.series?.name) || paint?.seriesName || '';
                const seriesSlug = (paint?.series?.slug) || paint?.seriesSlug || paint?.series?.urlSlug || '';
                const paintSlug = paint?.slug || paint?.paintSlug || '';
                const finishRaw = paint?.finishId ?? paint?.finish?.id ?? paint?.finish;
                const typeRaw = paint?.typeId ?? paint?.type?.id ?? paint?.type;
                const mediumRaw = paint?.mediumId ?? paint?.medium?.id ?? paint?.medium;
                const finishName = resolveEnumLabel(filterDictionaries.finish, finishRaw, paint?.finishName || paint?.finish?.name || paint?.finish || '');
                const typeName = resolveEnumLabel(filterDictionaries.type, typeRaw, paint?.typeName || paint?.type?.name || paint?.type || '');
                const mediumName = resolveEnumLabel(filterDictionaries.medium, mediumRaw, paint?.mediumName || paint?.medium?.name || paint?.medium || '');
                const sku = paint?.sku || paint?.code || '';
                const colorHex = (paint?.hex) || paint?.colorHex || paint?.hexCode || paint?.swatchHex || '#475569';
                const tags = Array.isArray(paint?.tags) ? paint.tags : [];
                const threadId = extractCommentThreadId(paint);
                const commentCountRaw = resolveCommentCount(paint);
                const commentCount = (commentCountRaw !== null && commentCountRaw !== undefined && Number.isFinite(Number(commentCountRaw)))
                    ? Number(commentCountRaw)
                    : null;
                const voteThreadId = extractVoteThreadId(paint);
                const voteSummary = getVoteSummary(voteThreadId, paint);
                const voteScoreRaw = voteSummary?.score ?? null;
                const voteScore = Number.isFinite(Number(voteScoreRaw)) ? Number(voteScoreRaw) : null;
                const upVotes = Number.isFinite(Number(voteSummary?.upVotes)) ? Number(voteSummary?.upVotes) : null;
                const downVotes = Number.isFinite(Number(voteSummary?.downVotes)) ? Number(voteSummary?.downVotes) : null;
                const userVote = Number.isFinite(Number(voteSummary?.userVote)) ? Number(voteSummary?.userVote) : 0;
                const votePending = voteThreadId && state.pendingVoteThreads.has(voteThreadId);
                const safeName = escapeHtml(paint?.name || 'Untitled paint');
                const safeDescription = escapeHtml(paint?.description || '');
                const safeBrand = escapeHtml(brandName);
                const safeSeries = escapeHtml(seriesName);
                const safeFinish = escapeHtml(finishName);
                const safeType = escapeHtml(typeName);
                const safeMedium = escapeHtml(mediumName);
                const safeSku = escapeHtml(sku);
                const swatch = buildPaintSwatch(paint, colorHex, { defaultHex: '#475569' });
                const safeSwatchBackground = escapeHtml(swatch.background);
                const safeHex = escapeHtml(swatch.label || colorHex);
                const detailsUrl = generateDetailsUrl(brandSlug, seriesSlug, paintSlug);

                const tagsMarkup = tags
                    .map(tag => typeof tag === 'string' ? tag : (tag?.name || tag?.label))
                    .filter(Boolean)
                    .map(tag => `<span class="rounded-full bg-slate-100 px-2 py-0.5 text-xs text-slate-600 dark:bg-slate-800 dark:text-slate-200">${escapeHtml(tag)}</span>`)
                    .join('');

                const commentBadge = (threadId || commentCount !== null)
                    ? `<span class="inline-flex items-center gap-1 rounded-full border border-slate-200 px-2 py-1 text-[11px] font-semibold text-slate-600 dark:border-slate-700 dark:text-slate-200" title="${escapeHtml(labels.comments || 'Comments')}">
                            ${commentIcon}
                            <span>${commentCount !== null ? commentCount : '—'}</span>
                       </span>`
                    : '';

                const voteControls = voteThreadId
                    ? `<div class="inline-flex items-center gap-1 rounded-full border border-slate-200 bg-white/70 px-2 py-1 text-[11px] font-semibold text-slate-600 shadow-sm dark:border-slate-700 dark:bg-slate-800/60 dark:text-slate-200" data-vote-thread="${voteThreadId}">
                            <button type="button" data-vote-action="up" data-thread-id="${voteThreadId}" ${votePending ? 'disabled' : ''} class="grid h-6 w-6 place-items-center rounded-full ${userVote === 1 ? 'bg-emerald-500/20 text-emerald-600' : 'text-slate-500'} ${votePending ? 'opacity-60' : ''}" aria-label="${escapeHtml(labels?.votes?.up || 'Upvote')}">▲</button>
                            <span class="min-w-[1.75rem] text-center">${voteScore !== null ? voteScore : (Number.isFinite(upVotes) && Number.isFinite(downVotes) ? upVotes - downVotes : '—')}</span>
                            <button type="button" data-vote-action="down" data-thread-id="${voteThreadId}" ${votePending ? 'disabled' : ''} class="grid h-6 w-6 place-items-center rounded-full ${userVote === -1 ? 'bg-red-500/20 text-red-600' : 'text-slate-500'} ${votePending ? 'opacity-60' : ''}" aria-label="${escapeHtml(labels?.votes?.down || 'Downvote')}">▼</button>
                        </div>`
                    : '';

                const mainContent = `
                        <div class="space-y-3">
                            <div class="flex items-start justify-between gap-3">
                                <div>
                                    <p class="text-xs uppercase tracking-wide text-slate-400">${safeBrand || labels.brand || 'Brand'}</p>
                                    <h3 class="text-lg font-semibold text-slate-900 dark:text-white">${safeName}</h3>
                                    ${safeSeries ? `<p class="text-xs text-slate-500">${labels.series || 'Series'}: ${safeSeries}</p>` : ''}
                                </div>
                                <div class="flex flex-col items-end gap-2 text-right text-[11px] text-slate-500 dark:text-slate-300">
                                    <div class="h-12 w-12 rounded-xl border border-2 border-slate-200 dark:border-slate-700" style="background: ${safeSwatchBackground};"></div>
                                </div>
                            </div>
                        </div>
                        ${safeDescription ? `<p class="mt-3 text-sm text-slate-500 dark:text-slate-300">${safeDescription}</p>` : ''}
                        <dl class="mt-4 grid grid-cols-2 gap-3 text-xs text-slate-500">
                            <div>
                                <dt class="font-semibold text-slate-400">${labels.finish || 'Finish'}</dt>
                                <dd class="text-sm text-slate-900 dark:text-slate-100">${safeFinish || '—'}</dd>
                            </div>
                            <div>
                                <dt class="font-semibold text-slate-400">${labels.type || 'Type'}</dt>
                                <dd class="text-sm text-slate-900 dark:text-slate-100">${safeType || '—'}</dd>
                            </div>
                            <div>
                                <dt class="font-semibold text-slate-400">${labels.medium || 'Medium'}</dt>
                                <dd class="text-sm text-slate-900 dark:text-slate-100">${safeMedium || '—'}</dd>
                            </div>
                            <div>
                                <dt class="font-semibold text-slate-400">${labels.sku || 'SKU'}</dt>
                                <dd class="text-sm text-slate-900 dark:text-slate-100">${safeSku || '—'}</dd>
                            </div>
                        </dl>
                        ${tagsMarkup ? `<div class="mt-4 flex flex-wrap gap-2">${tagsMarkup}</div>` : ''}`;

                const actionSection = `
                        <div class="mt-4 flex items-center justify-between gap-3 text-xs text-slate-500">
                            <div class="flex items-center gap-2">
                                <span class="font-semibold uppercase tracking-wide">${labels.color || 'Color'}</span>
                                <span class="rounded-full border border-slate-200 px-2 py-0.5 text-slate-700 dark:border-slate-700 dark:text-slate-200">${safeHex}</span>
                            </div>
                            <div class="flex items-center gap-2">
                                ${voteControls}
                                ${commentBadge}
                            </div>
                        </div>`;

                const cardContent = detailsUrl
                    ? `<a href="${detailsUrl}" class="block focus:outline-none focus:ring-2 focus:ring-emerald-500">${mainContent}</a>`
                    : mainContent;

                return `
                    <article class="rounded-2xl border border-slate-200 bg-white/90 p-4 shadow-sm transition hover:-translate-y-0.5 hover:border-emerald-500 dark:border-slate-800 dark:bg-slate-900/80">
                        ${cardContent}
                        ${actionSection}
                    </article>`;
            }

            function generateDetailsUrl(brandSlug, seriesSlug, paintSlug) {
                if (!brandSlug || !seriesSlug || !paintSlug) return null;
                const template = endpoints.details || '';
                if (!template) return null;

                return template
                    .replace('__brand__', encodeURIComponent(brandSlug))
                    .replace('__series__', encodeURIComponent(seriesSlug))
                    .replace('__paint__', encodeURIComponent(paintSlug));
            }

            function renderPagination() {
                const container = elements.pagination;
                if (!container) return;

                const totalPages = Math.max(1, Math.ceil(state.total / state.pagination.pageSize));
                const shouldShow = state.total > state.pagination.pageSize;

                container.classList.toggle('hidden', !shouldShow);

                if (!shouldShow) {
                    return;
                }

                const info = elements.paginationInfo;
                if (info) {
                    info.textContent = `${state.pagination.page} / ${totalPages}`;
                }

                if (elements.prevPageBtn) {
                    elements.prevPageBtn.disabled = state.pagination.page <= 1;
                }

                if (elements.nextPageBtn) {
                    elements.nextPageBtn.disabled = state.pagination.page >= totalPages;
                }
            }

            function renderEmptyState() {
                if (!elements.empty) return;
                const shouldShowEmpty = !state.loading && state.items.length === 0;
                elements.empty.classList.toggle('hidden', !shouldShowEmpty);
            }

            function toggleLoading(isLoading) {
                state.loading = isLoading;
                if (elements.loading) {
                    elements.loading.classList.toggle('hidden', !isLoading);
                }

                if (elements.results) {
                    elements.results.classList.toggle('opacity-50', isLoading);
                }
            }

            function escapeHtml(value) {
                if (value === null || value === undefined) {
                    return '';
                }

                return String(value)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            }

            function debounce(fn, delay) {
                let timeout;
                return function (...args) {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => fn.apply(this, args), delay);
                };
            }
        });
    </script>
}
